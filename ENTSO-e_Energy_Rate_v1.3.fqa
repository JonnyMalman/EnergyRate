{"name":"ENTSO-e Energy Rate","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_755"},"sections":{"items":[{"components":[{"name":"labelInfo","style":{"weight":"1.2"},"text":"labelInfo","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"refreshButton","style":{"weight":"1.2"},"text":"Refresh","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_755"}}},"uiCallbacks":[{"callback":"refresh_action","eventType":"onReleased","name":"refreshButton"}],"quickAppVariables":[{"name":"ENTSOE_Token","type":"string","value":"f442d0b3-450b-46d7-b752-d8d692fdb2c8"},{"name":"EnergyTax","type":"string","value":"0"},{"name":"TariffHistory","type":"string","value":"365"},{"name":"OperatorCost","type":"string","value":"0"},{"name":"GridLossesPct","type":"string","value":"0"},{"name":"AdjustmentPct","type":"string","value":"0"},{"name":"DealerFee","type":"string","value":"0"},{"name":"LocalGridCost","type":"string","value":"0"},{"name":"PriceLow","type":"string","value":"0.2"},{"name":"PriceHigh","type":"string","value":"1.0"},{"name":"PriceVeryHigh","type":"string","value":"2.0"},{"name":"PriceMedium","type":"string","value":"0.50"},{"name":"PriceDecimals","value":"3"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":false,"content":"--[[\n    ENTSO-e Energy Rate is an FIBARO QuickApp that get current Spot prices for almost every european countries and is independent from any energy power company for free.\n\n    How to get your own Token:\n    I´ve provide an Token that works \"out of the box\", but can be changed in the future, so if you like you can create your own free token at ENTSO-e, but not required.\n    Register an ENTSO-e account at: https://transparency.entsoe.eu/\n    How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\n\n    The Exchange rate service (https://exchangerate.host) that is used in this QuickApp to get your local currency is also free to use and if you like it, donate a cappuccino at https://exchangerate.host/#/donate ;)\n\n    This is the first time I have developed in Lua language, so have some indulgence, but hey it works and I hope it works for U 2 ;)\n    I would appreciate if you have any feedback or suggestions to make this QuickApp more usefull, please send me an email at energyrate@jamdata.com and I´ll try to do my best :)\n\n    Changelog:\n    v1.0 First release 2023-01\n    \n    v1.1 New feature release 2023-03\n        - Keeps Tariff rate history in FIBARO.\n        - Show more usefull info in QA panel.\n        - Add new general month average level variable \"EnergyMonthLevel\" for those that pay energy consumtion per month average.\n        - Add new QA variable \"TariffHistory\" for how many days to store history in FIBARO tariff rates.\n        - Localized panel text for language: EN, DK, NO, SV (if you want to help me with translation, please send me an email at energyrate@jamdata.com)\n\n        Braking changes that you need to change in your scenes if your using first release v1.0:\n            General variable name change from \"EnergyRateArea\" to \"EnergyArea\".\n            General variable name change from \"EnergyRateMedium\" to \"EnergyMediumPrice\".\n            General variable name change from \"EnergyRateLevel\" to \"EnergyHourLevel\".\n            General variable name change from \"EnergyRateNextLevel\" to \"EnergyNextHourLevel\".\n\n    v1.2 Customer wishes release 2023-04\n        - Option to add tax to the energy price.\n        - Show if service error message.\n\n    v1.3 Customer improvements 2023-05\n        - Rewrite energy tariff table to store in general variable instead of FIBARO tariff table to solve negative energy prices.\n        - Fix UTC time when request next day energy prices from ENTSO-e.\n        - Improved energy value display formatting, with price decimal local variable, also show correct price if very low or negative price. (Except FIBARO tariff that can't show negative values)\n        - All the rate levels are  moved from general to local variables and are in real local energy price.\n        - Move general variable \"EnergyTaxPercentage\" to local variable as \"EnergyTax\".\n        - Add general variable ON/OFF to store prices in FIBARO Tariff rate table.\n        - Add translation in Portuguese (Thanks to Leandro C.).\n        - Add cost variables to calculate energy prices: {((ENTSO_price + operatorCost) x losses x adjustment) + dealer + localgrid} x tax (by Leandro C.).\n]]\n\nfunction QuickApp:onInit()\n    self.debugOn = false -- Write to debug console true/false\n    self.httpClient = net.HTTPClient()\n    \n    -- Variables for exchangerate.host Api service\n    -- https://exchangerate.host\n    self.exchangerate_baseURL = \"https://api.exchangerate.host/\"\n    self.exchangeRate = 1       -- Set default excahnge rate 1:1 for €\n\n    -- Variables for ENTSO-e Transparency Platform Api service\n    -- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html\n    self.entsoe_baseURL = \"https://web-api.tp.entsoe.eu/api\"\n    self.child_rank_name = \"ENTSO-e Next Energy Rate\"                   -- Name of next energy price QA child\n    self.next_rank_device_id = nil                                      -- Id of next energy price QA child\n\n    -- NOTE! Local QA variable names can only have maximun of 15 charachters\n    self.variable_token_name = \"ENTSOE_Token\"\n    self.variable_tariff_history_name = \"TariffHistory\"\n    self.variable_Low_name = \"PriceLow\"\n    self.variable_Medium_name = \"PriceMedium\"\n    self.variable_High_name = \"PriceHigh\"\n    self.variable_VeryHigh_name = \"PriceVeryHigh\"\n    self.variable_tax_percentage_name = \"EnergyTax\"\n    self.variable_price_decimals_name = \"PriceDecimals\"                 -- Variable name of number of decimals when display energy prices\n\n    self.variable_operator_cost_name = \"OperatorCost\"                   -- Variable name of Grid Operator deviation costs (€/kWh or €/MWh)\n    self.variable_grid_losses_name = \"GridLossesPct\"                    -- Variable name of Grid Losses percent cost (%)\n    self.variable_grid_adjustment_name = \"AdjustmentPct\"                -- Variable name of Grid Adjustment percent cost added to the Grid Losses (%)\n    self.variable_dealer_cost_name = \"DealerFee\"                        -- Variable name of Dealer fee cost (€/KWh or €/MWh)\n    self.variable_grid_cost_name = \"LocalGridCost\"                      -- Variable name of Local Grid cost (€/KWh or €/MWh)\n\n    -- Global variable names\n    self.global_var_unit_name = \"EnergyUnit\"                            -- Global variable name of energy unit (KWh or MWh)\n    self.global_var_state_table_name = \"EnergyStateTable\"               -- Global variable name of energy state table\n    self.global_var_area_name = \"EnergyArea\"\n    self.global_var_level_name = \"EnergyHourLevel\"\n    self.global_var_next_level_name = \"EnergyNextHourLevel\"\n    self.global_var_month_level_name = \"EnergyMonthLevel\"\n    self.global_var_fibaro_tariff_name = \"EnergyTariffInFibaro\"\n    \n    -- Default values to set if missing\n    self.default_token = \"f442d0b3-450b-46d7-b752-d8d692fdb2c8\"         -- See \"How to get your own Token:\" above.\n    self.default_area_name = \"[SELECT AREA]\"                            -- Need to select an area before request ENTSO-e\n    self.default_unit = \"kWh\"                                           -- Show kWh or MWh in display panel (FIBARO Tariff table is always in kWh)\n    self.default_tax = \"0\"                                              -- Default 0% energy tax\n    self.default_tariff_history = \"62\"                                  -- Default 62 days ~2 month\n\n    self.default_decimals = self:getDefaultPriceDecimals()              -- Get default number of decimals based on currency for prices display\n    self.default_Low_price = self:getDefaultRatePrice(10)               -- 10% of medium price based on local currency\n    self.default_Medium_price = self:getDefaultRatePrice(100)             -- 100% of medium price based on local currency\n    self.default_High_price = self:getDefaultRatePrice(160)             -- 160% of medium price based on local currency\n    self.default_VeryHigh_price = self:getDefaultRatePrice(250)         -- 250% of medium price based on local currency\n    \n    self.default_operator_cost = \"0\"                                    -- Default Grid Operator costs (0 €/kWh or 0 €/MWh)\n    self.default_grid_losses = \"0\"                                      -- Default Grid Losses in percent (0 %)\n    self.default_grid_adjustment = \"0\"                                  -- Default adjustment added to the Grid Losses in percent (0 %)\n    self.default_dealer_cost = \"0\"                                      -- Default Dealer cost (0 €/KWh or 0 €/MWh)\n    self.default_grid_cost = \"0\"                                        -- Default Local Grid cost (0 €/KWh or 0 €/MWh)\n\n    -- Fixed QA variables\n    self.nextday_releaseTime = 12                                       -- The UTC time of the day when ENTSO-e usually releses the next day prices\n    self.dateFormat = self:getDateFormat()                              -- The FIBARO Date format setting (\"YY-MM-DD\", \"DD.MM.YY\" or \"MM/DD/YY\") that will be converted to Lua date format\n    self.valueFormat = self:getValueFormat(self.default_decimals)       -- The value formatting of decimals when display Energy prices ie. \"%.2f\"\n    self.serviceRequestTime = \"--\"                                      -- Last datetime when we request ENTSO-e webservice.\n    self.serviceSuccess = true                                          -- Request ENTSO-e service success or fault\n    self.exchangeRateUpdated = true\n    self.serviceMessage = \"\"                                            -- Request ENTSO-e service error message\n    \n    -- Let´s start\n    self:mainStart()\nend\n\nfunction QuickApp:mainStart()\n    -- Create global varaiables (See: defaults)\n    self:createAreaVariables()    \n    self:createGlobalVariables()\n\n    -- Init Child device to display next hour rate in FIBARO (See: QAChild_NextRank)\n    self:initChildDevices({[\"com.fibaro.multilevelSensor\"] = ENTSOE_Next_Rank})\n    self:validateChildren()\n    \n    -- set default values (See: defaults)\n    self:setLocalVariables()           \n    \n    -- Start loop, one for request ENTSO-e service and exchange rate and one for updating global variables and panel display.\n    self:d(\">>>> Start ENTSO-e Energy Rate <<<<\")\n    self:serviceRequestLoop(true) -- Request ExchangeRate and ENTSO-e services\nend\n\n-- Trigger if panel refresh button pressed\nfunction QuickApp:refresh_action()\n    self:d(\"Execute ENTSO-e service update on button event...\")\n    self:updateView(\"refreshButton\", \"text\", \"⌛ \" ..self.i18n:get(\"Refreshing\") ..\"...\")\n    self:serviceRequestLoop(true)\nend\n\n-- ENTSO-e and Exchange rate service loop\nfunction QuickApp:serviceRequestLoop(forceUpdate)\n    -- Refresh variables\n    self:refreshVariables()\n    local serviceLoopTime = 60000\n\n    -- Check if table is already up to date, otherwise request service and update table  \n    if (self.areaCode ~= \"\") then\n        serviceLoopTime = 60 * 1000 * 60 -- Set Update service request loop to every hour\n        \n        -- Only get Energy Rates from ENSO-e Service if missing in EnergyStateTable\n        if (not self:IsEnergyTariffUpToDate() or forceUpdate) then self:updateTariffData() end\n    end\n\n    -- Start this Service request loop\n    fibaro.setTimeout(serviceLoopTime, function() self:serviceRequestLoop(false) end)\n\n    -- Update variables and panel\n    self:displayLoop(forceUpdate) \nend\n\nfunction QuickApp:updateTariffData()\n    -- Get current day energy rates.\n    -- ENTSO-e service only returns 24 hour Rates on each request even if we define another \"toDate\" :(\n    self:getServiceRateData(QuickApp.updateEnergyTariffTable, self, os.date(\"%Y%m%d0000\"), os.date(\"%Y%m%d2300\"), true)\n    \n    -- Get next 24 hour energy rates if they have been released, normally the next day energy rates are released after 12:00 UTC.\n    -- We also need the next day rates to solve the midnight shift between 23:00 and 00:00.\n    if (self.serviceSuccess and tonumber(os.date(\"%H\", os.time())) >= self:getRateReleaseTime(self.timezoneOffset)) then\n        fibaro.setTimeout(2000, function() \n                                    self:getServiceRateData(QuickApp.updateEnergyTariffTable, self, os.date(\"!%Y%m%d0000\", os.time() + 86400), os.date(\"!%Y%m%d2300\", os.time() + 86400), false) \n                                end)\n    end\n    \n    self.serviceRequestTime = os.date(self:getDateFormat()) ..\" \" ..os.date(\"%H:%M\")\nend\n\n-- Variables and panel update display loop\nfunction QuickApp:displayLoop(forceUpdate)\n    local loopTime = 5000\n\n    -- Set Update display loop to every full hour + 1 min\n    if not forceUpdate then loopTime = (61 - tonumber(os.date(\"%M\"))) * 60 * 1000 * 60 end\n\n    -- Get current Exchange rate from Exchangerate.host Api Service\n    local waitTime = 0\n    if (self.currency ~= \"EUR\") then -- If local currency already in Euro we don't need exchange rates.\n        self:getServiceExchangeData(QuickApp.setExchangeRate, self)\n        waitTime = 2000\n    end\n\n    -- Update FIBARO Tariff table (only wait 2 sec for Exchange rate http request to complete if currency not in EUR)\n    fibaro.setTimeout(waitTime, function() self:updateFibaroTariffTable() end)\n\n    -- Start this display loop each hour\n    fibaro.setTimeout(loopTime, function() self:displayLoop(false) end)\n\n     -- Refresh variable values\n    self:refreshVariables()\nend"},{"name":"nextRank_Child","isMain":false,"isOpen":false,"content":"class 'ENTSOE_Next_Rank' (QuickAppChild)\r\nfunction ENTSOE_Next_Rank:__init(device)\r\n    -- You should not insert code before QuickAppChild.__init.\r\n    QuickAppChild.__init(self, device) -- We must call a constructor from the parent class\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setValue(value)\r\n    self:updateProperty(\"value\", value)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setUnit(unit)\r\n    self:updateProperty(\"unit\", unit)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setLog(log)\r\n    self:updateProperty(\"log\", log)\r\nend\r\n\r\n\r\n-- Validate if child panel exists, if not create it\r\nfunction QuickApp:validateChildren()\r\n    self:d(\"Validate QuickApp Child\")\r\n    for id, device in pairs(self.childDevices) do\r\n        self:d(tostring(id) ..\" = \" ..device.name)\r\n\r\n        if (device.name == self.child_rank_name) then\r\n            self.next_rank_device_id = id\r\n            self:d(tostring(id) ..\" - child_rank_name: \" ..device.name)\r\n        end\r\n    end\r\n\r\n    if self.next_rank_device_id == nil then\r\n        self:d(\"Create QuickApp Child\")\r\n        self:createRankChild()\r\n    end\r\nend\r\n\r\n-- Create child panel\r\nfunction QuickApp:createRankChild()\r\n    local child = self:createChildDevice({\r\n        name = self.child_rank_name,\r\n        type = \"com.fibaro.multilevelSensor\",\r\n    }, ENTSOE_Next_Rank)\r\n    self.next_rank_device_id = child.id\r\nend"},{"name":"functions","isMain":false,"isOpen":false,"content":"-- Write to console if debug=true\r\nfunction QuickApp:d(msg)\r\n    if self.debugOn then self:debug(msg) end\r\nend\r\n\r\n-- Get Energy Tariff table from global variable\r\nfunction QuickApp:getEnergyTariffTable()\r\n    local tariffData = {}\r\n    local jsonString = fibaro.getGlobalVariable(self.global_var_state_table_name)\r\n    \r\n    -- Create global variable if missing\r\n    if (jsonString == nil) then self:createGlobalVariableTable() end\r\n\r\n    -- Decode json string to table\r\n    if (jsonString ~= nil and jsonString ~= \"\") then \r\n        tariffData = json.decode(jsonString)\r\n    end\r\n\r\n    return tariffData\r\nend\r\n\r\n-- Get currency symbol\r\nfunction QuickApp:getCurrencySymbol()\r\n    local currency = self.currency\r\n    if (currency == \"EUR\") then return \"€\" end\r\n    if (currency == \"USD\") then return \"$\" end\r\n    if (currency == \"GBP\") then return \"£\" end\r\n    if (currency == \"YEN\") then return \"¥\" end\r\n    if (currency == \"SEK\") then return \"Kr\" end\r\n    if (currency == \"NOK\") then return \"Kr\" end\r\n    if (currency == \"DKK\") then return \"Kr\" end\r\n    return currency\r\nend\r\n\r\n-- Get Lua date format from FIBARO date format\r\nfunction QuickApp:getDateFormat()\r\n    if self.dateFormat == \"YY-MM-DD\" then return \"%Y-%m-%d\" end\r\n    if self.dateFormat == \"DD.MM.YY\" then return \"%d.%m.%Y\" end\r\n    if self.dateFormat == \"MM/DD/YY\" then return \"%m/%d/%Y\" end\r\n    return \"%Y-%m-%d\"\r\nend\r\n\r\n-- Get value format\r\nfunction QuickApp:getValueFormat()\r\n    if (self.decimals == nil) then self.decimals = self:getDefaultPriceDecimals() end\r\n    return \"%.\" ..tostring(self.decimals) ..\"f\"\r\nend\r\n\r\nfunction QuickApp:toLocalDateId(dateString, addHour, timezoneOffset)\r\n    if dateString == \"\" then return \"\" end\r\n    if addHour == nil then addHour = 0 end\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n    -- Convert input dateString = \"2022-12-25 23:00\" to table Id date \"22122523\"\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+) (%d+):(%d+)\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute}) + timezoneOffset\r\n    return os.date(\"%y%m%d%H\", timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:toDate(dateId, format, addHour)\r\n    if dateId == nil or dateId == \"\" then return \"\" end\r\n    if format == nil then format = \"%Y-%m-%d %H:%M\" end\r\n    if addHour == nil then addHour = 0 end\r\n    -- Convert input dateId = \"22122523\" to Lua date format\r\n    local iyear, imonth, iday, ihour = dateId:match(\"^(%d%d)(%d%d)(%d%d)(%d%d)$\")\r\n    local timestamp = os.time({year = iyear + 2000, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:toDefault(value)\r\n    if value == nil or value == \"nan\" then return \"0\" end\r\n    return value\r\nend\r\n\r\n-- Get ENTSO-e next day price release date in local time\r\nfunction QuickApp:getRateReleaseTime(timezoneOffset)\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n    return tonumber(os.date(\"!%H\", os.time({year=2000, month=1, day=1, hour=self.nextday_releaseTime, min=0}) + timezoneOffset))\r\nend\r\n\r\n-- Count items in a Lua table\r\nfunction QuickApp:tableCount(T)\r\n    local count = 0\r\n    if T == nil or T == \"\" then return count end\r\n    for _ in pairs(T) do count = count + 1 end\r\n    return count\r\nend\r\n\r\n-- Convert xml input dateString = \"2022-12-25T23:00Z\" to Lua date\r\nfunction QuickApp:getXmlDate(xmlString, name, format)\r\n    local dateString = self:getXmlElement(xmlString, name)\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+)Z\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp)\r\nend\r\n\r\n-- Get xml element value\r\nfunction QuickApp:getXmlElement(data, name)\r\n    return data:match(\"<\"..name..\">(.-)</\"..name..\">\")\r\nend\r\n\r\n-- Extract ENTSO-e prices from response xml into Lua table\r\nfunction QuickApp:xml2PriceTable(xml)\r\n    local priceTable = {}\r\n    local ni, c, label, xarg, empty\r\n    local i, j = 1, 1\r\n\r\n    while true do\r\n        ni, j, c, label, xarg, empty = string.find(xml, \"<(%/?)([%w:_]+)(.-)(%/?)>\", i)\r\n        if not ni then break end\r\n        local text = string.sub(xml, i, ni-1)\r\n   \r\n        if not string.find(text, \"^%s*$\") and label == \"price\" then\r\n            table.insert(priceTable, text)\r\n        end\r\n\r\n        i = j+1\r\n    end\r\n\r\n    return priceTable\r\nend\r\n\r\nfunction QuickApp:getLocalTariffRate(rawRate, exchangeRate, unit, tax, operator, losses, adjustment, dealer, grid)\r\n    if (exchangeRate == nil) then exchangeRate = 1 end\r\n    if (tax == nil or tax == 0) then tax = 1 end\r\n    if (tax > 1) then tax = (tax / 100) + 1 end -- Convert input tax from % to decimal if > 1\r\n    \r\n    if (operator == nil) then operator = 0 end\r\n    if (losses == nil or losses == 0) then losses = 1 end\r\n    if (losses > 1) then losses = (losses / 100) + 1 end -- Convert input losses in % to decimal if > 1\r\n    if (adjustment == nil or adjustment == 0) then adjustment = 1 end\r\n    if (adjustment > 1) then adjustment = (adjustment / 100) + 1 end -- Convert input adjustment in % to decimal if > 1\r\n    if (dealer == nil) then dealer = 0 end\r\n    if (grid == nil) then grid = 0 end\r\n\r\n    -- Get Unit scale. ENTSO-e always return prices in €/MWh\r\n    local unitScale = 1000 -- kWh\r\n    if (unit == \"MWh\") then unitScale = 1 end \r\n    \r\n    -- Recalculate main rate from EUR/mWh to {local currency}/{MWh or kWh} * tax\r\n    local rate = string.format(\"%f\", ((((((rawRate * exchangeRate) / unitScale) + operator) * losses * adjustment) + dealer + grid) * tax))\r\n    return tonumber(rate)\r\nend\r\n\r\nfunction QuickApp:getRank(value)\r\n    -- Set defaults if not valid input value\r\n    if (value == nil or value == \"nan\" or value == \"--\") then return \"\" end\r\n    value = tonumber(value)\r\n\r\n    -- Return price rank from variable rank values\r\n    local rank = \"VeryLOW\"\r\n    if (value >= self.low_price) then rank = \"LOW\" end\r\n    if (value >= self.medium_price) then rank = \"MEDIUM\" end\r\n    if (value >= self.high_price) then rank = \"HIGH\" end\r\n    if (value >= self.veryhigh_price) then rank = \"VeryHIGH\" end\r\n\r\n    self:d(\"Set the rank level value \" ..value ..\" = \" ..rank)\r\n\r\n    return rank\r\nend\r\n\r\nfunction QuickApp:getRankIcon(value)\r\n    if (value == \"VeryHIGH\") then return \"🔴\" end\r\n    if (value == \"HIGH\") then return \"🟠\" end\r\n    if (value == \"MEDIUM\") then return \"🟡\" end\r\n    if (value == \"LOW\") then return \"🔵\" end\r\n    if (value == \"VeryLOW\") then return \"🟢\" end\r\n    return \"⛔\" -- Wrong value\r\nend\r\n\r\nfunction QuickApp:getNextDirection(currentValue, nextValue)\r\n    -- ⬆️⬇️➡️ or ⇧⇨⇩\r\n    if (currentValue == nil) then currentValue = 0 end\r\n    if (nextValue == nil) then nextValue = 0 end\r\n    if (currentValue > nextValue) then return \"⬇️\" end\r\n    if (currentValue < nextValue) then return \"⬆️\" end\r\n    return \"➡️\"\r\nend"},{"name":"defaults","isMain":false,"isOpen":false,"content":"function QuickApp:createGlobalVariableTable()\r\n    -- Create Energy state table global variable\r\n    local table_var = {\r\n            name=self.global_var_state_table_name,\r\n            isEnum=false,\r\n            readOnly=true,\r\n            value=\"\"\r\n        }\r\n    response, status = api.post('/globalVariables/', table_var)\r\n    self:d(\"Create global variable: \" ..tostring(table_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\nend\r\n\r\nfunction QuickApp:createGlobalVariables()\r\n    -- Create Energy store in FIBARO Tariff global variable\r\n    local tariff_var = {\r\n            name=self.global_var_fibaro_tariff_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"ON\",\r\n            enumValues={\"ON\",\"OFF\"}\r\n        }\r\n    response, status = api.post('/globalVariables/', tariff_var)\r\n    self:d(\"Create global variable: \" ..tostring(tariff_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\n\r\n    -- Create Energy Unit global variable\r\n    local unit_var = {\r\n            name=self.global_var_unit_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_unit,\r\n            enumValues={\"kWh\",\"MWh\"}\r\n        }\r\n    response, status = api.post('/globalVariables/', unit_var)\r\n    self:d(\"Create global variable: \" ..tostring(unit_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\n\r\n    -- Create Level rate global variable\r\n    local level_var = {\r\n            name=self.global_var_level_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"HIGH\",\r\n            enumValues={\"VeryLOW\",\"LOW\",\"MEDIUM\",\"HIGH\",\"VeryHIGH\"}\r\n        }\r\n    response, status = api.post('/globalVariables/', level_var)\r\n    self:d(\"Create global variable: \" ..tostring(level_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\n\r\n    -- Create Next Level rate global variable\r\n    level_var.name = self.global_var_next_level_name\r\n    response, status = api.post('/globalVariables/', level_var)\r\n    self:d(\"Create global variable: \" ..tostring(level_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\n\r\n    -- Create Month Level rate global variable\r\n    level_var.name = self.global_var_month_level_name\r\n    response, status = api.post('/globalVariables/', level_var)\r\n    self:d(\"Create global variable: \" ..tostring(level_var.name) ..\" => \" ..tostring(status) ..\" - \" ..tostring(response.message))\r\n\r\n    self:d(\"FIBARO Global variables crated.\")\r\nend\r\n\r\nfunction QuickApp:setLocalVariables()\r\n    -- Not required, but you can register and create your own account and get a token at ENTSO-e.\r\n    -- Register an free ENTSO-e account at: https://transparency.entsoe.eu/\r\n    -- How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf \r\n    self.token = self:getLocalVariable(self.variable_token_name, self.default_token)\r\n\r\n    -- Get/Set local rate price variables\r\n    self.low_price = tonumber(self:getLocalVariable(self.variable_Low_name, self.default_Low_price))\r\n    self.medium_price = tonumber(self:getLocalVariable(self.variable_Medium_name, self.default_Medium_price))\r\n    self.high_price = tonumber(self:getLocalVariable(self.variable_High_name, self.default_High_price))\r\n    self.veryhigh_price = tonumber(self:getLocalVariable(self.variable_VeryHigh_name, self.default_VeryHigh_price))\r\n\r\n    -- Get/Set local variable price decimals\r\n    self.decimals = self:getLocalVariable(self.variable_price_decimals_name, self.default_decimals)\r\n    -- Get/Set local variable Days to keep FIBARO Tariff history\r\n    self.tariffHistory = self:getLocalVariable(self.variable_tariff_history_name, self.default_tariff_history)\r\n    -- Get/Set local variable tax\r\n    self.tax = self:getLocalVariable(self.variable_tax_percentage_name, self.default_tax)\r\n    \r\n    -- Get/Set local variable operator cost\r\n    self.operatorCost = self:getLocalVariable(self.variable_operator_cost_name, self.default_operator_cost)\r\n    -- Get/Set local variable grid losses in percent\r\n    self.gridLosses = self:getLocalVariable(self.variable_grid_losses_name, self.default_grid_losses)\r\n    -- Get/Set local variable grid adjustment in percent\r\n    self.gridAdjustment = self:getLocalVariable(self.variable_grid_adjustment_name, self.default_grid_adjustment)\r\n    -- Get/Set local variable dealer cost\r\n    self.dealerCost = self:getLocalVariable(self.variable_dealer_cost_name, self.default_dealer_cost)\r\n    -- Get/Set local variable grid cost\r\n    self.gridCost = self:getLocalVariable(self.variable_grid_cost_name, self.default_grid_cost)\r\n\r\n    -- Get/Set global FIBARO variables\r\n    self.areaName = self:getGlobalFibaroVariable(self.global_var_area_name, self.default_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self.unit = self:getGlobalFibaroVariable(self.global_var_unit_name, self.default_unit)\r\n\r\n    self:refreshVariables()\r\nend\r\n\r\nfunction QuickApp:refreshVariables()\r\n    -- Get FIBARO settings\r\n    local fibaroSettings = api.get(\"/settings/info\")\r\n    self.currency = fibaroSettings.currency\r\n    self.timezoneOffset = tonumber(fibaroSettings.timezoneOffset)\r\n    self.dateFormat = fibaroSettings.dateFormat\r\n    self.i18n = i18n:new(fibaroSettings.defaultLanguage)\r\n    \r\n    -- Refrech global variables\r\n    self.areaName = fibaro.getGlobalVariable(self.global_var_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self.tariffData = self:getEnergyTariffTable()\r\n    self.unit = fibaro.getGlobalVariable(self.global_var_unit_name) \r\n\r\n    -- Refresh QA variable values\r\n    self.token = self:getVariable(self.variable_token_name)\r\n    self.tariffHistory = tonumber(self:getVariable(self.variable_tariff_history_name))\r\n    self.low_price = tonumber(self:getVariable(self.variable_Low_name))\r\n    self.high_price = tonumber(self:getVariable(self.variable_High_name))\r\n    self.veryhigh_price = tonumber(self:getVariable(self.variable_VeryHigh_name))\r\n    self.tax = tonumber(self:getVariable(self.variable_tax_percentage_name))\r\n    self.decimals = self:getVariable(self.variable_price_decimals_name)\r\n    self.valueFormat = self:getValueFormat()\r\n\r\n    self.operatorCost = tonumber(self:getVariable(self.variable_operator_cost_name))\r\n    self.gridLosses = tonumber(self:getVariable(self.variable_grid_losses_name))\r\n    self.gridAdjustment = tonumber(self:getVariable(self.variable_grid_adjustment_name))\r\n    self.dealerCost = tonumber(self:getVariable(self.variable_dealer_cost_name))\r\n    self.gridCost = tonumber(self:getVariable(self.variable_grid_cost_name))\r\n\r\n    if (self.currency ~= nil and self.unit ~= nil) then\r\n        self:updateProperty(\"unit\", self.currency .. \"/\" ..self.unit)\r\n    end\r\n\r\n    -- Set Energy rates data to display\r\n    self:displayEnergyRate()\r\nend\r\n\r\n-- Get local QA variable, set to default value if variable is missing\r\nfunction QuickApp:getLocalVariable(name, defaultValue)\r\n    local value = self:getVariable(name)\r\n\r\n    if (value == nil or value == \"\" or value == \"nil\") then\r\n        self:setVariable(name, tostring(defaultValue))\r\n        return defaultValue\r\n    else\r\n        return value\r\n    end\r\nend\r\n\r\n-- Get local QA variable, set to default value if variable is missing\r\nfunction QuickApp:getGlobalFibaroVariable(name, defaultValue)\r\n    local value = fibaro.getGlobalVariable(name)\r\n\r\n    if (value == nil or value == \"\" or value == \"nil\") then\r\n        fibaro.setGlobalVariable(name, tostring(defaultValue))\r\n        return defaultValue\r\n    else\r\n        return value\r\n    end\r\nend\r\n\r\n-- Get default rate price based in local currency\r\nfunction QuickApp:getDefaultPriceDecimals()\r\n    if (self.currency == nil or self.currency == \"\") then\r\n        local fibaroSettings = api.get(\"/settings/info\")\r\n        self.currency = fibaroSettings.currency\r\n    end\r\n\r\n    -- TODO: do an more accurat difference between currencies\r\n    if (self.currency == \"EUR\" or self.currency == \"USD\" or self.currency == \"GBP\") then\r\n        return \"5\"\r\n    else\r\n        return \"3\"\r\n    end\r\nend\r\n\r\n-- Get default rate price based in local currency\r\nfunction QuickApp:getDefaultRatePrice(percent)\r\n    if (self.currency == nil or self.currency == \"\") then\r\n        local fibaroSettings = api.get(\"/settings/info\")\r\n        self.currency = fibaroSettings.currency\r\n    end\r\n\r\n    -- TODO: do an more accurat difference between currencies\r\n    if (self.currency == \"EUR\" or self.currency == \"USD\" or self.currency == \"GBP\") then\r\n        return tostring(0.2 * (percent / 100))\r\n    else\r\n        return tostring(1 * (percent / 100))\r\n    end\r\nend"},{"name":"display","isMain":false,"isOpen":false,"content":"function QuickApp:displayEnergyRate()   \r\n    -- ENTSO-e Energy Area not selected\r\n    if self.areaCode == nil or self.areaCode == \"\" then\r\n        self:updateView(\"labelInfo\", \"text\", \"\\n💡 \" ..self.i18n:get(\"NoSelectedArea\") ..\"\\n\\n\\n\")\r\n        self:updateView(\"refreshButton\", \"text\", \"⚠️  \" ..self.i18n:get(\"Refresh\") ..\"  ⚠️\")\r\n        self:d(\"No EnergyArea selected!\")\r\n        return\r\n    end\r\n\r\n    -- Get current Fibaro Tariff Data\r\n    local tariffData = self:getEnergyRateData()\r\n    \r\n    -- Calculate values\r\n    local rank = self:getRank(tariffData.currentRate)\r\n    local nextRank = self:getRank(tariffData.nextRate)\r\n    local nextDir = self:getNextDirection(tariffData.currentRate, tariffData.nextRate)\r\n    local prevDir = self:getNextDirection(tariffData.previousRate, tariffData.currentRate)\r\n    local rateDiff = string.format(self.valueFormat, tariffData.nextRate - tariffData.currentRate)\r\n    local prevDiff = string.format(self.valueFormat, tariffData.currentRate - tariffData.previousRate)\r\n\r\n    -- Set dafaults\r\n    local avgRate = 0\r\n    local avgRank = \"\"\r\n    local refresh = \"♻️\"\r\n    local serviceUpdated = refresh\r\n    local lastRqt = refresh ..self.i18n:get(\"LoadingEnergyRates\") ..\"️...\"\r\n    local lastUpd = refresh ..self.i18n:get(\"Refreshing\") ..\"️...\"    \r\n    local areaName = self.areaName\r\n    local areaCode = self.areaCode\r\n\r\n    -- Set Exchange rate\r\n    local exchangeRate = \"--\"\r\n    if (self.exchangeRate > 0) then exchangeRate = string.format(self.valueFormat, self.exchangeRate) end\r\n\r\n    -- If Service request failed\r\n    if self.serviceSuccess == false then\r\n        refresh = \"⚠️\"\r\n        lastUpd = \"--\"\r\n        areaCode = \"--\"\r\n        serviceUpdated = \"--\"\r\n        areaName = self.areaName ..\"\\n\" ..refresh ..\" \" ..self.i18n:get(\"MissingEnergyRatesForSelectedArea\")\r\n        if (self.serviceMessage ~= \"\") then areaName = areaName ..\"\\n⛔ \" ..self.serviceMessage ..\"\\n\" end\r\n    end\r\n\r\n    -- Only update variables and tariff if we got \"real\" rate data\r\n    if tariffData.energyPricesUpdated == true and self.exchangeRateUpdated == true then\r\n        avgTotalRank = self:getRank(tariffData.avgTotalRate)\r\n        avgDayRank = self:getRank(tariffData.avgDayRate)\r\n        avgMonthRank = self:getRank(tariffData.avgMonthRate)\r\n\r\n        self:updateProperty('value', tonumber(tariffData.currentRate))\r\n        self:updateProperty('log', self:getRankIcon(rank) ..rank)\r\n        \r\n        fibaro.setGlobalVariable(self.global_var_level_name, rank)        \r\n        fibaro.setGlobalVariable(self.global_var_next_level_name, nextRank)\r\n        fibaro.setGlobalVariable(self.global_var_month_level_name, avgMonthRank)\r\n\r\n        if (self.next_rank_device_id ~= nil) then\r\n            fibaro.call(self.next_rank_device_id, 'setLog', self:getRankIcon(nextRank) ..nextRank)\r\n            fibaro.call(self.next_rank_device_id, 'setUnit', \" \" .. nextDir)\r\n            fibaro.call(self.next_rank_device_id, 'setValue', rateDiff)\r\n        end\r\n        \r\n        serviceUpdated = self.serviceRequestTime\r\n        lastUpd = os.date(\"%Y-%m-%d %H:%M\")\r\n        refresh = \"\"\r\n        \r\n        self:d(\"Display panels updated: \" ..os.date(\"%H:%M:%S\"))\r\n    end\r\n\r\n    -- Update FIBARO Info panel\r\n    local labelInfo = self.i18n:get(\"TodayRates\") ..\" (\" ..self.i18n:get(\"Range\") ..\": \" ..tariffData.minDayRate ..\" ~ \" ..tariffData.maxDayRate ..\" \" ..self:getCurrencySymbol() ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(rank) ..\" \" ..self.i18n:get(\"CurrentHour\") ..\": \" ..tariffData.currentRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..prevDiff ..\" \" ..prevDir ..\") - \" ..self.i18n:get(rank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(nextRank) ..\" \" ..self.i18n:get(\"NextHour\") ..\": \" ..tariffData.nextRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..rateDiff ..\" \" ..nextDir ..\") - \" ..self.i18n:get(nextRank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgDayRank) ..\" \" ..self.i18n:get(\"TodayAverage\") ..\": \" .. tariffData.avgDayRate ..\" \" ..self:getCurrencySymbol() ..\" - \" ..self.i18n:get(avgDayRank) ..\"\\n\\n\"\r\n\r\n    if (tariffData.nextDayRate == true) then\r\n        local avgNextDayRank = self:getRank(tariffData.avgNextDayRate)\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRateRange\") ..\": \" ..tariffData.minNextDayRate ..\" ~ \" ..tariffData.maxNextDayRate ..\" \" ..self:getCurrencySymbol() ..\"\\n\"\r\n        labelInfo = labelInfo ..self:getRankIcon(avgNextDayRank) ..\" \" ..self.i18n:get(\"TomorrowAverage\") ..\": \" ..tariffData.avgNextDayRate ..\" \" ..self:getCurrencySymbol() ..\" - \" ..self.i18n:get(avgNextDayRank) ..\"\\n\\n\"\r\n    else\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRatesReleases\") ..\" \" ..self:getRateReleaseTime(self.timezoneOffset) ..\":00 (UTC: \" ..self.nextday_releaseTime ..\":00)\\n\"\r\n        labelInfo = labelInfo ..\"🕓 \" ..self.i18n:get(\"TomorrowAverage\") ..\": --\\n\\n\"\r\n    end\r\n\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRatePeriod\") ..\": \" ..tariffData.firstDate ..\" -- \" ..tariffData.lastDate ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgMonthRank) ..\" \" ..self.i18n:get(\"ThisMonthAverage\") .. \": \" ..tariffData.avgMonthRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..string.format(\"%.0f\", tariffData.avgMonthCount/24) ..\" \" ..self.i18n:get(\"Days\") ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgTotalRank) ..\" \" ..self.i18n:get(\"TotalTariffAverage\") .. \": \" ..tariffData.avgTotalRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..string.format(\"%.0f\", tariffData.count/24) ..\" \"  ..self.i18n:get(\"Days\") ..\")\" ..\"\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyArea\") ..\": \" ..areaName ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"AreaCode\") ..\": \" ..areaCode ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRateHistory\") ..\": \" ..self.tariffHistory ..\" \" ..self.i18n:get(\"days\") ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"LowRatePrice\") ..\": \" ..self.low_price ..\" ~ \" ..self.medium_price ..\" \" ..self:getCurrencySymbol() ..\"/\" ..self.unit ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"MediumRatePrice\") ..\": \" ..self.medium_price ..\" ~ \" ..self.high_price ..\" \" ..self:getCurrencySymbol() ..\"/\" ..self.unit ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"HighRatePrice\") ..\": \" ..self.high_price ..\" ~ \" ..self.veryhigh_price ..\" \" ..self:getCurrencySymbol() ..\"/\" ..self.unit ..\"\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyRateUpdate\") ..\": \" ..serviceUpdated ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"VariableUpdate\") ..\": \" ..lastUpd ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"FibaroTariff\") ..\": \" ..fibaro.getGlobalVariable(self.global_var_fibaro_tariff_name) ..\"\\n\"\r\n\r\n    -- Only show if Tax value is set\r\n    if (self.tax ~= nil and self.tax ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"Tax\") ..\": \" ..string.format(\"%.2f\", self.tax) ..\"%\"\r\n    end\r\n\r\n    -- Only show if Operator value is set\r\n    if (self.operatorCost ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"OperatorCost\") ..\": \" ..self.operatorCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n    -- Only show if Losses value is set\r\n    if (self.gridLosses ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridLosses\") ..\": \" ..string.format(\"%.2f\", self.gridLosses) ..\"%\"\r\n    end\r\n    -- Only show if Adjustment value is set\r\n    if (self.gridAdjustment ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridAdjustment\") ..\": \" ..string.format(\"%.2f\", self.gridAdjustment) ..\"%\"\r\n    end\r\n    -- Only show if Dealer value is set\r\n    if (self.dealerCost ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"DealerCost\") ..\": \" ..self.dealerCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n    -- Only show if Grid value is set\r\n    if (self.gridCost ~= 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridCost\") ..\": \" ..self.gridCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n\r\n    -- Only show if exchange currency is not in Euro\r\n    if (self.currency ~= \"EUR\") then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..self.i18n:get(\"ExchangeRate\") ..\": 1 € = \" ..exchangeRate ..\" \" ..self:getCurrencySymbol()\r\n    end\r\n    \r\n    -- If missing translation, just to trigger users to help me with translations ;)\r\n    if not (self.i18n.isTranslated) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..\"💡 \"..self.i18n:get(\"MissingTranslation\") ..\": \" ..self.i18n.languageCode\r\n    end\r\n\r\n    self:updateView(\"labelInfo\", \"text\", labelInfo)\r\n    self:updateView(\"refreshButton\", \"text\", self.i18n:get(\"Refresh\"))\r\n\r\n    self:d(\"Current (\" ..self.i18n:get(rank) ..\") Rate: \" ..tariffData.currentRate ..\" \" ..self.currency ..\"/kWh, Next (\" ..nextRank ..\") Rate: \" ..tariffData.nextRate ..\" \" ..self.currency ..\"/kWh\" ..\" (\" ..rateDiff ..nextDir ..\")\")\r\nend"},{"name":"exchangeRate","isMain":false,"isOpen":false,"content":"-- Exchange rates API is a simple and lightweight free service for current and historical foreign exchange rates & crypto exchange rates.\r\n-- Reliable and up-to-date EU VAT rates, sourced directly from the European Commission's databases.\r\n-- If you like it, donate a cappuccino https://exchangerate.host/#/donate ;)\r\n\r\n-- Service home site: https://exchangerate.host\r\n\r\nfunction QuickApp:setExchangeRate(responseData)\r\n    if responseData == nil then\r\n        self.exchangeRateUpdated = false\r\n        self:debug(\"Exchange Rate: Error when request rate!\")\r\n    end\r\n\r\n    for curr, value in pairs(responseData.rates) do\r\n        self.exchangeRate = tonumber(value)\r\n        self:d(\"Exchange Rate: 1 EUR = \" .. value .. \" \" .. curr)\r\n    end\r\nend\r\n\r\nfunction QuickApp:getServiceExchangeData(callback, instance)\r\n    -- Request exchangerate.host with base currency \"EUR\" that always is ENTSO-e response currency\r\n    local url = self.exchangerate_baseURL .. \"latest?base=EUR&symbols=\" .. self.currency .. \"&amount=1\"\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {[\"Accept\"] = \"application/json\"}\r\n        },\r\n        success = function(response)\r\n            local success, data = pcall(function()\r\n                                            return json.decode(response.data)\r\n                                        end)\r\n\r\n            if success then\r\n                self.exchangeRateUpdated = true\r\n                pcall(callback, instance, data)\r\n            else\r\n                self.exchangeRateUpdated = false\r\n                self:debug(\"Broken json response from Url: \" .. url)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self.exchangeRateUpdated = false\r\n            self:debug(\"Error:\", message)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_GetEnergyRate","isMain":false,"isOpen":false,"content":"-- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_generation_domain\r\n-- 4.2.10. Day Ahead Rates [12.1.D]\r\n\r\nfunction QuickApp:getServiceRateData(callback, instance, fromdate, todate, reportError)\r\n    self:d(\"Request ENTSO-e for period UTC: \" .. fromdate .. \" -- \" .. todate .. \" (AreaCode: \" .. self.areaCode .. \")\")\r\n\r\n    local ratePrices = {}\r\n    local url = self.entsoe_baseURL .. \"?documentType=A44&in_Domain=\" .. self.areaCode .. \"&out_Domain=\" .. self.areaCode .. \"&periodStart=\" .. fromdate .. \"&periodEnd=\" .. todate .. \"&securityToken=\" .. self.token\r\n\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {\r\n                [\"SECURITY_TOKEN\"] = self.token,\r\n                [\"Accept\"] = \"text/xml\"\r\n            }\r\n        },\r\n        success = function(response)\r\n            -- Create Rate table from XML response\r\n            local periodXml = self:getXmlElement(response.data, \"Period\")\r\n            local success, data = pcall(function()\r\n                                            return self:xml2PriceTable(periodXml) -- Extact rate prices from XML\r\n                                        end)                                        \r\n            if success then\r\n                if data == nil then\r\n                    if (reportError == true) then\r\n                        self.serviceSuccess = false\r\n                        self.serviceMessage = \"ERROR: Empty response from Url \" ..url\r\n                        self:debug(self.serviceMessage)\r\n                    end\r\n                    return nil\r\n                end\r\n\r\n                -- Get UTC start and end date from response XML\r\n                local startDate = self:getXmlDate(periodXml, \"start\", \"%Y-%m-%d %H:%M\")\r\n                local endDate = self:getXmlDate(periodXml, \"end\", \"%Y-%m-%d %H:%M\")\r\n\r\n                -- Create local date and rate table\r\n                for index, rate in pairs(data) do\r\n                    local ratePrice = {\r\n                        id = self:toLocalDateId(startDate, index - 1, self.timezoneOffset),\r\n                        rate = tonumber(rate)\r\n                    }\r\n                    table.insert(ratePrices, ratePrice)\r\n                end\r\n\r\n                self:d(\"=> Response: Start UTC = \" .. startDate .. \", End UTC = \" .. endDate .. \", \" .. self:tableCount(ratePrices) .. \" rates\")\r\n                \r\n                self.serviceSuccess = true\r\n                self.serviceMessage = \"\"\r\n\r\n                pcall(callback, instance, ratePrices)\r\n            else\r\n                if (reportError == true) then\r\n                    self.serviceSuccess = false\r\n                    self.serviceMessage = \"Error: Can't get energy prices from ENTSO-e\"\r\n                    self:debug(self.serviceMessage)\r\n                end\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            if (reportError == true) then\r\n                self.serviceSuccess = false\r\n                self.serviceMessage = \"Error: \" ..message\r\n                self:debug(self.serviceMessage)\r\n            end\r\n            return nil\r\n        end\r\n    })\r\nend"},{"name":"entsoe_AreaCodes","isMain":false,"isOpen":false,"content":"-- See \"BZN\" Area codes at: https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_areas\r\n\r\nfunction QuickApp:createAreaVariables()\r\n    local level_var = {\r\n            name=self.global_var_area_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_area_name,\r\n            enumValues={\"[SELECT AREA]\", \"Austria (AT)\",\"Belgium (BE)\",\"Bosnia and Herz. (BA)\",\"Bulgaria (BG)\",\"Croatia (HR)\",\"Czech Republic (CZ)\",\"Denmark (DK1)\",\"Denmark (DK2)\",\"Estonia (EE)\",\"Finland (FI)\",\"France (FR)\",\"Germany (DE-LU)\",\"Greece (GR)\",\"Hungary (HU)\",\"Ireland (SEM)\",\"Italy (Calabria)\",\"Italy (SACOAC)\",\"Italy (SACODC)\",\"Italy (Centre-North)\",\"Italy (Centre-South)\",\"Italy (North)\",\"Italy (Sardinia)\",\"Italy (Sicily)\",\"Italy (South)\",\"Latvia (LV)\",\"Lithuania (LT)\",\"Luxembourg (LU)\",\"Netherlands (NL)\",\"North Macedonia (MK)\",\"Norway (NO1)\",\"Norway (NO2)\",\"Norway (NO2NSL)\",\"Norway (NO3)\",\"Norway (NO4)\",\"Norway (NO5)\",\"Poland (PL)\",\"Portugal (PT)\",\"Romania (RO)\",\"Serbia (RS)\",\"Slovakia (SK)\",\"Slovenia (SI)\",\"Spain (ES)\",\"Sweden (SE1)\",\"Sweden (SE2)\",\"Sweden (SE3)\",\"Sweden (SE4)\",\"Switzerland (CH)\",\"Ukraine (UA-IPS)\",\"United Kingdom (GB)\"}\r\n    }\r\n    api.post('/globalVariables/',level_var)    \r\nend\r\n\r\nfunction QuickApp:getAreaCode(areaName)\r\n    -- Set default Area code if \"areaName\" is missing.\r\n    if areaName == nil or areaName == \"\" then areaName = self.default_area_name end\r\n    \r\n    if (areaName == \"[SELECT AREA]\") then return \"\" end\r\n    if (areaName == \"Austria (AT)\") then return \"10YAT-APG------L\" end\r\n    if (areaName == \"Belgium (BE)\") then return \"10YBE----------2\" end\r\n    if (areaName == \"Bosnia and Herz. (BA)\") then return \"10YBA-JPCC-----D\" end\r\n    if (areaName == \"Bulgaria (BG)\") then return \"10YCA-BULGARIA-R\" end\r\n    if (areaName == \"Croatia (HR)\") then return \"10YHR-HEP------M\" end\r\n    if (areaName == \"Czech Republic (CZ)\") then return \"10YCZ-CEPS-----N\" end\r\n    if (areaName == \"Denmark (DK1)\") then return \"10YDK-1--------W\" end\r\n    if (areaName == \"Denmark (DK2)\") then return \"10YDK-2--------M\" end\r\n    if (areaName == \"Estonia (EE)\") then return \"10Y1001A1001A39I\" end\r\n    if (areaName == \"Finland (FI)\") then return \"10YFI-1--------U\" end\r\n    if (areaName == \"France (FR)\") then return \"10YFR-RTE------C\" end\r\n    if (areaName == \"Germany (DE-LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Greece (GR)\") then return \"10YGR-HTSO-----Y\" end\r\n    if (areaName == \"Hungary (HU)\") then return \"10YHU-MAVIR----U\" end\r\n    if (areaName == \"Ireland (SEM)\") then return \"10Y1001A1001A59C\" end\r\n    if (areaName == \"Italy (Calabria)\") then return \"10Y1001C--00096J\" end\r\n    if (areaName == \"Italy (Centre-North)\") then return \"10Y1001A1001A70O\" end\r\n    if (areaName == \"Italy (Centre-South)\") then return \"10Y1001A1001A71M\" end\r\n    if (areaName == \"Italy (North)\") then return \"10Y1001A1001A73I\" end\r\n    if (areaName == \"Italy (SACOAC)\") then return \"10Y1001A1001A885\" end\r\n    if (areaName == \"Italy (SACODC)\") then return \"10Y1001A1001A893\" end\r\n    if (areaName == \"Italy (Sardinia)\") then return \"10Y1001A1001A74G\" end\r\n    if (areaName == \"Italy (Sicily)\") then return \"10Y1001A1001A75E\" end\r\n    if (areaName == \"Italy (South)\") then return \"10Y1001A1001A788\" end\r\n    if (areaName == \"Latvia (LV)\") then return \"10YLV-1001A00074\" end\r\n    if (areaName == \"Lithuania (LT)\") then return \"10YLT-1001A0008Q\" end\r\n    if (areaName == \"Luxembourg (LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Netherlands (NL)\") then return \"10YNL----------L\" end\r\n    if (areaName == \"North Macedonia (MK)\") then return \"10YMK-MEPSO----8\" end\r\n    if (areaName == \"Norway (NO1)\") then return \"10YNO-1--------2\" end\r\n    if (areaName == \"Norway (NO2)\") then return \"10YNO-2--------T\" end\r\n    if (areaName == \"Norway (NO2NSL)\") then return \"50Y0JVU59B4JWQCU\" end\r\n    if (areaName == \"Norway (NO3)\") then return \"10YNO-3--------J\" end\r\n    if (areaName == \"Norway (NO4)\") then return \"10YNO-4--------9\" end\r\n    if (areaName == \"Norway (NO5)\") then return \"10Y1001A1001A48H\" end\r\n    if (areaName == \"Poland (PL)\") then return \"10YPL-AREA-----S\" end\r\n    if (areaName == \"Portugal (PT)\") then return \"10YPT-REN------W\" end\r\n    if (areaName == \"Romania (RO)\") then return \"10YRO-TEL------P\" end\r\n    if (areaName == \"Serbia (RS)\") then return \"10YCS-SERBIATSOV\" end\r\n    if (areaName == \"Slovakia (SK)\") then return \"10YSK-SEPS-----K\" end\r\n    if (areaName == \"Slovenia (SI)\") then return \"10YSI-ELES-----O\" end\r\n    if (areaName == \"Spain (ES)\") then return \"10YES-REE------0\" end\r\n    if (areaName == \"Sweden (SE1)\") then return \"10Y1001A1001A44P\" end\r\n    if (areaName == \"Sweden (SE2)\") then return \"10Y1001A1001A45N\" end\r\n    if (areaName == \"Sweden (SE3)\") then return \"10Y1001A1001A46L\" end\r\n    if (areaName == \"Sweden (SE4)\") then return \"10Y1001A1001A47J\" end\r\n    if (areaName == \"Switzerland (CH)\") then return \"10YCH-SWISSGRIDZ\" end\r\n    if (areaName == \"Ukraine (UA-IPS)\") then return \"10Y1001C--000182\" end\r\n    if (areaName == \"United Kingdom (GB)\") then return \"10YGB----------A\" end\r\n\r\n    return \"\" -- No match\r\nend"},{"name":"i18n","isMain":false,"isOpen":false,"content":"class \"i18n\"\r\n\r\nphrases = {\r\n    en = {\r\n        [\"Refreshing\"] = \"Refreshing\",\r\n        [\"LoadingEnergyRates\"] = \"Loading energy rates\",\r\n        [\"Refresh\"] = \"Refresh\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Missing Energy rates for selected energy area\",\r\n        [\"ExchangeRate\"] = \"Exchange rate\",\r\n        [\"TodayRates\"] = \"Todays rates\",\r\n        [\"Range\"] = \"Range\",\r\n        [\"To\"] = \"to\",\r\n        [\"CurrentHour\"] = \"Current hour\",\r\n        [\"NextHour\"] = \"Next hour\",\r\n        [\"TodayAverage\"] = \"Today average\",\r\n        [\"TomorrowRatesReleases\"] = \"Tomorrow rates releases after\",\r\n        [\"TomorrowAverage\"] = \"Tomorrow average\",\r\n        [\"TomorrowRateRange\"] = \"Tomorrow rate range\",\r\n        [\"TariffRatePeriod\"] = \"Tariff rate period\",\r\n        [\"ThisMonthAverage\"] = \"This month average\",\r\n        [\"TotalTariffAverage\"] = \"Total tariff average\",\r\n        [\"Days\"] = \"Days\",\r\n        [\"days\"] = \"days\",\r\n        [\"EnergyArea\"] = \"Energy area\",\r\n        [\"AreaCode\"] = \"ENTSO-e AreaCode\",\r\n        [\"LanguageCode\"] = \"Language Code\",\r\n        [\"TariffRateHistory\"] = \"Tariff rate history\",\r\n        [\"LowRatePrice\"] = \"Low rate price\",\r\n        [\"MediumRatePrice\"] = \"Medium rate price\",\r\n        [\"HighRatePrice\"] = \"High rate price\",\r\n        [\"Tax\"] = \"Energy prices include tax of\",\r\n        [\"OperatorCost\"] = \"Operator cost\",\r\n        [\"GridLosses\"] = \"Grid Losses percent cost\",\r\n        [\"GridAdjustment\"] = \"Adjustment percent cost\",\r\n        [\"DealerCost\"] = \"Dealer cost\",\r\n        [\"GridCost\"] = \"Local Grid cost\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff rates\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Price update\",\r\n        [\"VariableUpdate\"] = \"Panel update\",\r\n        [\"NoSelectedArea\"] = \"Please select [EnergyArea] in FIBARO general variables.\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    dk = {\r\n        [\"Refreshing\"] = \"Opdatering\",\r\n        [\"LoadingEnergyRates\"] = \"Indlæsning af energisatser\",\r\n        [\"Refresh\"] = \"Opdatering\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Manglende energisatser for udvalgt energiområde\",\r\n        [\"ExchangeRate\"] = \"Valutakurs\",\r\n        [\"TodayRates\"] = \"I dag kurser\",\r\n        [\"Range\"] = \"Rækkevidde\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuel time\",\r\n        [\"NextHour\"] = \"Næste time\",\r\n        [\"TodayAverage\"] = \"Dagens gennemsnit\",\r\n        [\"TomorrowRatesReleases\"] = \"Priserne i morgen offentliggøres\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gennemsnit\",\r\n        [\"TomorrowRateRange\"] = \"Prisinterval i morgen\",\r\n        [\"TariffRatePeriod\"] = \"Tarifperiode\",\r\n        [\"ThisMonthAverage\"] = \"Gennemsnit i denne måned\",\r\n        [\"TotalTariffAverage\"] = \"Samlet tarifgennemsnit\",\r\n        [\"Days\"] = \"Dage\",\r\n        [\"days\"] = \"dage\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"ENTSO-e Områdenummer\",\r\n        [\"LanguageCode\"] = \"Sprogkode\",\r\n        [\"TariffRateHistory\"] = \"Tarifhistorie\",\r\n        [\"LowRatePrice\"] = \"Lav pris\",\r\n        [\"MediumRatePrice\"] = \"Mellempris pris\",\r\n        [\"HighRatePrice\"] = \"Høj pris\",\r\n        [\"Tax\"] = \"Priserne er inklusive moms\",\r\n        [\"OperatorCost\"] = \"Operatøromkostninger\",\r\n        [\"GridLosses\"] = \"Nettab i procent omkostninger\",\r\n        [\"GridAdjustment\"] = \"Justeringsprocent omkostninger\",\r\n        [\"DealerCost\"] = \"Forhandler omkostninger\",\r\n        [\"GridCost\"] = \"Lokale netomkostninger\",\r\n        [\"FibaroTariff\"] = \"FIBARO tarifsatser\",\r\n        [\"NoSelectedArea\"] = \"Vælg venligst [EnergyArea] i FIBARO generelle variabler.\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Energirate opdatering\",\r\n        [\"VariableUpdate\"] = \"Panel opdatering\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    no = {\r\n        [\"Refreshing\"] = \"Oppdaterer\",\r\n        [\"LoadingEnergyRates\"] = \"Laster spotpriser\",\r\n        [\"Refresh\"] = \"Oppdater\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser mangler for valgt energiområde\",\r\n        [\"ExchangeRate\"] = \"Vekslingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"Område\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuell time\",\r\n        [\"NextHour\"] = \"Neste time\",\r\n        [\"TodayAverage\"] = \"Dagens gjennomsnittsverdi\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgendagens priser er sluppet\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gjennomsnitt\",\r\n        [\"TomorrowRateRange\"] = \"Morgendagens omfang\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiode\",\r\n        [\"ThisMonthAverage\"] = \"Nåværende måneds gjennomsnitt\",\r\n        [\"TotalTariffAverage\"] = \"Gjennomsnittlig verdi totalt sett\",\r\n        [\"Days\"] = \"Dager\",\r\n        [\"days\"] = \"dager\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"Områdeskode (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"Språkkode\",\r\n        [\"TariffRateHistory\"] = \"Tariffhistorie\",\r\n        [\"LowRatePrice\"] = \"Lav pris\",\r\n        [\"MediumRatePrice\"] = \"Gjennomsnittspris\",\r\n        [\"HighRatePrice\"] = \"Høy pris\",\r\n        [\"Tax\"] = \"Prisene inkluderer skatt\",\r\n        [\"OperatorCost\"] = \"Operatørkostnad\",\r\n        [\"GridLosses\"] = \"Nettap prosent kostnad\",\r\n        [\"GridAdjustment\"] = \"Justering prosent kostnad\",\r\n        [\"DealerCost\"] = \"Forhandlerkostnad\",\r\n        [\"GridCost\"] = \"Lokale nettkostnader\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariffsatser\",\r\n        [\"NoSelectedArea\"] = \"Vennligst velg [EnergyArea] i FIBARO generelle variabler.\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Spotpriser sist oppdatert\",\r\n        [\"VariableUpdate\"] = \"Panel sist oppdatert\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    pt = {\r\n        [\"Refreshing\"] = \"Em atualização\",\r\n        [\"LoadingEnergyRates\"] = \"A carregar preços\",\r\n        [\"Refresh\"] = \"Atualizar\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Preços inexistentes para o local selecionado\",\r\n        [\"ExchangeRate\"] = \"Taxa de câmbio\",\r\n        [\"TodayRates\"] = \"Preços de hoje\",\r\n        [\"Range\"] = \"Intervalo\",\r\n        [\"To\"] = \"a\",\r\n        [\"CurrentHour\"] = \"Hora atual\",\r\n        [\"NextHour\"] = \"Hora seguinte\",\r\n        [\"TodayAverage\"] = \"Média de hoje\",\r\n        [\"TomorrowRatesReleases\"] = \"Indicação dos preços para amanhã\",\r\n        [\"TomorrowAverage\"] = \"Preço médio de amanhã\",\r\n        [\"TomorrowRateRange\"] = \"Intervalo de preços para amanhã\",\r\n        [\"TariffRatePeriod\"] = \"Período tarifário\",\r\n        [\"ThisMonthAverage\"] = \"Média do mês atual\",\r\n        [\"TotalTariffAverage\"] = \"Preço médio total\",\r\n        [\"Days\"] = \"Dias\",\r\n        [\"days\"] = \"dias\",\r\n        [\"EnergyArea\"] = \"Local\",\r\n        [\"AreaCode\"] = \"Código do local\",\r\n        [\"LanguageCode\"] = \"Código de idioma\",\r\n        [\"TariffRateHistory\"] = \"Histórico de preços\",\r\n        [\"LowRatePrice\"] = \"Preço de taxa baixa\",\r\n        [\"MediumRatePrice\"] = \"Preço médio\",\r\n        [\"HighRatePrice\"] = \"Preço de taxa alta\",\r\n        [\"Tax\"] = \"Preço inclui taxa de\",       \r\n        [\"OperatorCost\"] = \"Desvios e serviços do operador de sistema\",\r\n        [\"GridLosses\"] = \"Perdas de rede\",\r\n        [\"GridAdjustment\"] = \"Fator de adequação ORD\",\r\n        [\"DealerCost\"] = \"Custo de gestão\",\r\n        [\"GridCost\"] = \"Taxa de Acesso às Redes\",\r\n        [\"FibaroTariff\"] = \"Tarifas FIBARO\",\r\n        [\"NoSelectedArea\"] = \"Selecione [EnergyArea] nas variáveis gerais FIBARO.\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Atualização do preço\",\r\n        [\"VariableUpdate\"] = \"Atualização de variações\",\r\n        [\"MissingTranslation\"] = \"Tradução inexistente para este idioma\",\r\n        [\"VeryHIGH\"] = \"Muito ALTO\",\r\n        [\"HIGH\"] = \"ALTO\",\r\n        [\"MEDIUM\"] = \"RAZOÁVEL\",\r\n        [\"LOW\"] = \"BAIXO\",\r\n        [\"VeryLOW\"] = \"Muito BAIXO\",\r\n    },\r\n    sv = {\r\n        [\"Refreshing\"] = \"Uppdaterar\",\r\n        [\"LoadingEnergyRates\"] = \"Laddar spotpriser\",\r\n        [\"Refresh\"] = \"Uppdatera\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser saknas för valt energiområde\",\r\n        [\"ExchangeRate\"] = \"Växlingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"Omfång\",\r\n        [\"To\"] = \"till\",\r\n        [\"CurrentHour\"] = \"Innevarande timme\",\r\n        [\"NextHour\"] = \"Kommande timme\",\r\n        [\"TodayAverage\"] = \"Dagens medelvärde\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgondagens priser släpps efter\",\r\n        [\"TomorrowAverage\"] = \"Morgondagens medelvärde\",\r\n        [\"TomorrowRateRange\"] = \"Morgondagens omfång\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiod\",\r\n        [\"ThisMonthAverage\"] = \"Innevarande månads medelvärde\",\r\n        [\"TotalTariffAverage\"] = \"Medelvärde totalt\",\r\n        [\"Days\"] = \"Dagar\",\r\n        [\"days\"] = \"dagar\",\r\n        [\"EnergyArea\"] = \"Energiområde\",\r\n        [\"AreaCode\"] = \"Områdeskod (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"Språkkod\",\r\n        [\"TariffRateHistory\"] = \"Tariff historik\",\r\n        [\"LowRatePrice\"] = \"Lågt pris\",\r\n        [\"MediumRatePrice\"] = \"Medelpris\",\r\n        [\"HighRatePrice\"] = \"Högt pris\",\r\n        [\"Tax\"] = \"Priserna inkluderar skatt med\",\r\n        [\"OperatorCost\"] = \"Operatörskostnad\",\r\n        [\"GridLosses\"] = \"Nätförlustskostnad\",\r\n        [\"GridAdjustment\"] = \"Nät justeringskostnad\",\r\n        [\"DealerCost\"] = \"Leverantörskostnad\",\r\n        [\"GridCost\"] = \"Lokal nätkostnad\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff priser\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Spotpriser uppdaterad\",\r\n        [\"VariableUpdate\"] = \"Panel senast uppdaterad\",\r\n        [\"NoSelectedArea\"] = \"Inget elområde valt i generella variabler [EnergyArea].\",       \r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    }\r\n}\r\n\r\nfunction i18n:new(langCode)\r\n    self.isTranslated = true\r\n    if phrases[langCode] == nil then \r\n        langCode = \"en\"\r\n        self.isTranslated = false\r\n    end\r\n    self.languageCode = langCode\r\n    self.phrases = phrases[langCode]\r\n    return self\r\nend\r\n\r\nfunction i18n:get(key)\r\n    if key == nil then return \"\" end\r\n    if self.phrases[key] then return self.phrases[key] end\r\n    return key\r\nend"},{"name":"fibaroTariffRate","isMain":false,"isOpen":true,"content":"-- Update FIBARO Tariff rate table\r\nfunction QuickApp:updateFibaroTariffTable()\r\n    -- Exit if no data in global table or we got Service error\r\n    if (self:getGlobalFibaroVariable(self.global_var_fibaro_tariff_name, \"ON\") == \"OFF\" or self:tableCount(self.tariffData[self.areaName]) == 0 or self.serviceSuccess == false) then return end\r\n\r\n    -- Get current FIBARO Energy Tariff rate data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n    local currRate = tariffData.rate\r\n    local addTariffs = {}\r\n    local currentRateTime = os.date(\"%y%m%d%H\")\r\n    local count = 0\r\n\r\n    -- Update FIBARO Additional Tariff table in local currency/kWh and local timezone\r\n    for index, tariff in pairs(self.tariffData[self.areaName]) do\r\n        local startTime = self:toDate(tariff.id, \"%H:%M\", 0)\r\n        local endTime = self:toDate(tariff.id, \"%H:%M\", 1)\r\n        local tariffName = self:toDate(tariff.id, self:getDateFormat(), 0) ..\" \" ..startTime ..\" (\" ..tariff.rate ..\" €/MWh)\"\r\n\r\n        -- FIBARO only display price in kWh\r\n        local locRate = self:getLocalTariffRate(tariff.rate, self.exchangeRate, \"kWh\", self.tax, self.operatorCost, self.gridLosses, self.gridAdjustment, self.dealerCost, self.gridCost)\r\n\r\n        -- FIBARO Tariff table can't have negative values :(\r\n        if (locRate <= 0) then\r\n            tariffName = tariffName ..\" \" ..string.format(\"%f\", locRate) ..\" ⛔\"\r\n            locRate = 0.00001\r\n        end\r\n\r\n        -- Get current rate\r\n        if (tariff.id == currentRateTime) then \r\n            currRate = locRate\r\n            tariffName = tariffName ..\" ⭐\"\r\n            self:d(\"Current energy price: \"..tariff.rate ..\"=\" ..currRate ..\" at exchange: \" ..self.exchangeRate ..\" Unit: \" ..self.unit ..\" ID: \" ..tariff.id ..\" - \" ..tariffName)\r\n        end\r\n        \r\n        -- Add additional tariff to local tariff table\r\n        local newTariff = {\r\n            name = tariffName,\r\n            rate = locRate,\r\n            startTime = startTime,\r\n            endTime = endTime,\r\n            days = {string.lower(self:toDate(tariff.id, \"%A\", 0))}\r\n        }\r\n        table.insert(addTariffs, newTariff)\r\n        count = count + 1\r\n    end\r\n\r\n    -- Save new tariff table to FIBARO Tariff table\r\n    local response, code = api.put(\"/energy/billing/tariff\", {\r\n        returnRate = tariffData.returnRate,\r\n        additionalTariffs = addTariffs,\r\n        name = tariffData.name,\r\n        rate = currRate\r\n    })\r\n\r\n    self:d(\" => Update \" ..count ..\" FIBARO Tariffs with response code: \" .. tostring(code) .. \" - \\\"\" .. tariffData.name .. \"\\\" Rate: \" .. tariffData.rate .. \" => \" .. currRate)\r\nend"},{"name":"entsoe_TariffTable","isMain":false,"isOpen":false,"content":"function QuickApp:updateEnergyTariffTable(energyRateTable)\r\n    -- Exit if no data from ENTSO-e\r\n    if self:tableCount(energyRateTable) == 0 then return end\r\n\r\n    -- Set local variables\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    local tariffHourHistory = self.tariffHistory * 24\r\n    local updateTariff = false\r\n\r\n    -- Get current Energy Tariff data from global variables if empty\r\n    local tblCount = self:tableCount(self.tariffData[self.areaName])\r\n    if (tblCount == 0) then self.tariffData = self:getEnergyTariffTable() end\r\n    local areaRates = self.tariffData[self.areaName]\r\n    if (areaRates == nil) then areaRates = {} end\r\n\r\n    -- Add ENTSO-e raw rates to Energy tariff table if not already exists\r\n    local totalRate = 0;\r\n    \r\n    for index, tariff in pairs(energyRateTable) do\r\n        totalRate = totalRate + tariff.rate\r\n        if not (self:existsInEnergyTariffTable(areaRates, tariff.id)) then\r\n            table.insert(areaRates, tariff)\r\n            updateTariff = true\r\n            self:d(\"New ENTSO-e Energy rate added: \" ..tariff.id ..\" = \" ..tariff.rate)\r\n        end\r\n    end\r\n\r\n    -- If all rates in response table is 0 then not update Energy Tariff table, something is wrong!?\r\n    if (totalRate == 0) then\r\n        self.serviceSuccess = false -- Something got wrong in ENTSO-e request\r\n        self:d(\"Error in ENTSO-e Energy rate data!\")\r\n        return\r\n    end\r\n\r\n    -- Update Energy Tariff table if need to clean history\r\n    if updateTariff then tblCount = self:tableCount(areaRates) end\r\n    if (tblCount > tariffHourHistory) then updateTariff = true end\r\n\r\n    -- Update Energy tariff rates with sorted and cleaned Tariff data\r\n    if updateTariff then\r\n        -- Sort tariff table by Id (DateTime)\r\n        table.sort(areaRates, function (t1, t2) return t1.id < t2.id end )\r\n\r\n        -- Clean old Energy tartiff rates\r\n        if (tariffHourHistory > 0 and tariffHourHistory < tblCount) then\r\n            local cleanTariffs = {}\r\n            local startIndex = tblCount - tariffHourHistory\r\n            for index, tariff in pairs(tariffRates) do\r\n                if index > startIndex then\r\n                    table.insert(cleanTariffs, tariff)\r\n                end\r\n            end\r\n            areaRates = cleanTariffs\r\n            self:d(\"Energy tariff table cleaned from old history: \" ..startIndex ..\" hours\")\r\n        end\r\n\r\n        -- Save Energy tariff table to FIBARO global variable\r\n        self.tariffData[self.areaName] = areaRates\r\n        fibaro.setGlobalVariable(self.global_var_state_table_name, json.encode(self.tariffData))\r\n        self:d(\"Energy Tariff table updated in FIBARO global variables\")\r\n    end\r\nend\r\n\r\nfunction QuickApp:getEnergyRateData()\r\n    -- Get current Energy Tariff data from global variables if empty\r\n    local tblCount = self:tableCount(self.tariffData)\r\n    if (tblCount == 0) then self.tariffData = self:getEnergyTariffTable() end\r\n    local areaRates = self.tariffData[self.areaName]\r\n    if areaRates == nil then areaRates = {} end\r\n\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    \r\n    local energyPricesUpdated = false\r\n    local nowFormat = \"%y%m%d%H\"         -- Local timezone \"YYMMDDHH\"\r\n    local dayDate = os.date(\"%y%m%d\")    -- Local timezone \"YYMMDD\"\r\n    local monthDate = os.date(\"%y%m\")    -- Local timezone \"YYMM\"\r\n    local nextDayDate = os.date(\"%y%m%d\", os.time() + 86400)\r\n    local oneHour = 1 * 60 * 60          -- 1 hour\r\n    local previousRate = self.high_price -- Set default to High price\r\n    local currentRate = self.high_price  -- Set default to High price\r\n    local nextRate = self.high_price     -- Set default to High price\r\n    local totalCount = 0\r\n    local totalRate = 0\r\n    local totalDayCount = 0\r\n    local totalDayRate = 0\r\n    local totalMonthCount = 0\r\n    local totalMonthRate = 0\r\n    local minDayRate = 9999\r\n    local maxDayRate = 0\r\n    local totalNextDayCount = 0\r\n    local totalNextDayRate = 0    \r\n    local minNextDayRate = 9999\r\n    local maxNextDayRate = 0\r\n    local avgNextDayRate = 0\r\n    local nextDayRate = false\r\n    local firstIdDate = \"\"\r\n    local lastIdDate = \"\"\r\n\r\n    -- Sum each FIBARO tariff rate (Rate is in €/MWh and id is in local format \"YYMMDDHH\")\r\n    if (tblCount > 0) then\r\n        for index, tariff in pairs(areaRates) do\r\n            -- Set first and last id\r\n            if index == 1 then firstIdDate = tariff.id end\r\n            lastIdDate = tariff.id\r\n\r\n            -- Calculate Local Tariff Rate\r\n            local locRate = self:getLocalTariffRate(tariff.rate, self.exchangeRate, self.unit, self.tax, self.operatorCost, self.gridLosses, self.gridAdjustment, self.dealerCost, self.gridCost)\r\n\r\n            -- Set total values\r\n            totalRate = totalRate + locRate\r\n            totalCount = totalCount + 1\r\n            energyPricesUpdated = true\r\n\r\n            -- Sum today values \"YYMMDD\"\r\n            if (string.sub(tariff.id, 1, 6) == dayDate) then\r\n                totalDayRate = totalDayRate + locRate\r\n                totalDayCount = totalDayCount + 1\r\n                if locRate < minDayRate then minDayRate = locRate end\r\n                if locRate > maxDayRate then maxDayRate = locRate end\r\n            end\r\n            \r\n            -- Sum current month values \"YYMM\"\r\n            if (string.sub(tariff.id, 1, 4) == monthDate) then\r\n                totalMonthRate = totalMonthRate + locRate\r\n                totalMonthCount = totalMonthCount + 1\r\n            end\r\n\r\n            -- Sum tomorrow values\r\n            if (string.sub(tariff.id, 1, 6) == nextDayDate) then\r\n                totalNextDayRate = totalNextDayRate + locRate\r\n                totalNextDayCount = totalNextDayCount + 1\r\n                if locRate < minNextDayRate then minNextDayRate = locRate end\r\n                if locRate > maxNextDayRate then maxNextDayRate = locRate end\r\n            end\r\n\r\n            -- Set previous, current and next rate values\r\n            if (tariff.id == os.date(nowFormat, os.time() - oneHour)) then previousRate = locRate end\r\n            if (tariff.id == os.date(nowFormat, os.time()))           then currentRate = locRate end\r\n            if (tariff.id == os.date(nowFormat, os.time() + oneHour)) then nextRate = locRate end\r\n        end\r\n    end\r\n\r\n    -- Set minimum day rates to 0 if 9999\r\n    if (minNextDayRate >= 9999) then minNextDayRate = 0 end\r\n    if (minDayRate >= 9999) then minDayRate = 0 end\r\n    \r\n    -- Calculate tomorrow average values\r\n    if (totalNextDayCount > 0) then \r\n        avgNextDayRate = totalNextDayRate / totalNextDayCount \r\n        nextDayRate = true\r\n    end\r\n\r\n    -- Set return Tariff Data table\r\n    local tariffData = {\r\n        energyPricesUpdated = energyPricesUpdated,\r\n        count = totalCount,\r\n        previousRate = string.format(self.valueFormat, previousRate),\r\n        currentRate = string.format(self.valueFormat, currentRate),\r\n        nextRate = string.format(self.valueFormat, nextRate),\r\n        avgTotalRate = self:toDefault(string.format(self.valueFormat, totalRate / totalCount)),\r\n        avgDayRate = self:toDefault(string.format(self.valueFormat, totalDayRate / totalDayCount)),\r\n        avgDayCount = totalDayCount,\r\n        avgMonthRate = self:toDefault(string.format(self.valueFormat, totalMonthRate / totalMonthCount)),\r\n        avgMonthCount = totalMonthCount,\r\n        minDayRate = string.format(self.valueFormat, minDayRate),\r\n        maxDayRate = string.format(self.valueFormat, maxDayRate),\r\n        nextDayRate = nextDayRate,\r\n        avgNextDayRate = self:toDefault(string.format(self.valueFormat, avgNextDayRate)),\r\n        minNextDayRate = string.format(self.valueFormat, minNextDayRate),\r\n        maxNextDayRate = string.format(self.valueFormat, maxNextDayRate),\r\n        firstDate = self:toDate(firstIdDate, \"%Y-%m-%d\"),\r\n        lastDate = self:toDate(lastIdDate, \"%Y-%m-%d\")\r\n    }\r\n\r\n    self:d(\"Energy tariff - Count: \" ..tariffData.count ..\" (History \" ..(self.tariffHistory * 24) ..\" h), Previous Rate: \" ..tariffData.previousRate ..\", Current Rate: \" ..tariffData.currentRate ..\", next Rate: \" ..tariffData.nextRate ..\", Total avrage Rate: \" ..tariffData.avgTotalRate)\r\n\r\n    return tariffData\r\nend\r\n\r\nfunction QuickApp:IsEnergyTariffUpToDate()\r\n    local tblCount = self:tableCount(self.tariffData[self.areaName])\r\n    if (tblCount == 0) then return false end\r\n\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    local tariffHourHistory = self.tariffHistory * 24\r\n    local dateFormat = \"%y%m%d%H\"\r\n    local oneHour = 1 * 60 * 60        -- 1 hour\r\n    local nextDayShift = 24 * 60 * 60  -- 24 hours\r\n    local keepHistory = false\r\n    local previousExists = false\r\n    local currentExist = false\r\n    local nextExists = false\r\n    local nextDayExists = true\r\n\r\n    if (tblCount > tariffHourHistory) then \r\n        self:d(\"Energy tariff table need to be cleaned!\")\r\n        return false\r\n    end\r\n\r\n    -- ENTSO-e relese next day energy rate prices after 12:00 UTC each day\r\n    if (tonumber(os.date(\"%H\", os.time())) >= self:getRateReleaseTime(self.timezoneOffset)) then nextDayExists = false end\r\n\r\n    -- Check FIBARO Tariff if all rates already exists\r\n    for _, tariff in pairs(self.tariffData[self.areaName]) do\r\n        if (tariff.id == os.date(dateFormat, os.time() - oneHour))      then previousExists = true end\r\n        if (tariff.id == os.date(dateFormat, os.time()))                then currentExist = true end\r\n        if (tariff.id == os.date(dateFormat, os.time() + oneHour))      then nextExists = true end\r\n        if (tariff.id == os.date(dateFormat, os.time() + nextDayShift)) then nextDayExists = true end\r\n        \r\n        if previousExists and currentExist and nextExists and nextDayExists then\r\n            self:d(\"Energy tariff table is already up to date\")\r\n            return true\r\n        end   \r\n    end\r\n\r\n    self:d(\"Energy tariff table need to be updated!\")\r\n    return false\r\nend\r\n\r\n-- Check if rate already exists in Energy tariff table\r\nfunction QuickApp:existsInEnergyTariffTable(rates, match)\r\n    if rates == nil then return false end\r\n    for index, data in pairs(rates) do\r\n        if (tostring(data.id) == tostring(match)) then return true end\r\n    end\r\n    self:d(\"Energy tariff id \" ..match ..\" not exists!\")\r\n    return false\r\nend"}]}