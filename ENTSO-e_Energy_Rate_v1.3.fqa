{"name":"ENTSO-e Energy Rate","type":"com.fibaro.multilevelSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_749"},"sections":{"items":[{"components":[{"name":"labelInfo","style":{"weight":"1.2"},"text":"labelInfo","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"refreshButton","style":{"weight":"1.2"},"text":"Refresh","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_749"}}},"uiCallbacks":[{"callback":"refresh_action","eventType":"onReleased","name":"refreshButton"}],"quickAppVariables":[{"name":"ENTSOE_Token","type":"string","value":"f442d0b3-450b-46d7-b752-d8d692fdb2c8"},{"name":"PriceLow","type":"string","value":"0.01"},{"name":"PriceHigh","type":"string","value":"0.5"},{"name":"PriceVeryHigh","type":"string","value":"1.0"},{"name":"EnergyTax","type":"string","value":"0"},{"name":"PriceDecimals","type":"string","value":"4"},{"name":"TariffHistory","type":"string","value":"365"},{"name":"OperatorCost","type":"string","value":"0"},{"name":"GridLossesPct","type":"string","value":"0"},{"name":"AdjustmentPct","type":"string","value":"0"},{"name":"DealerFee","type":"string","value":"0"},{"name":"LocalGridCost","type":"string","value":"0"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"--[[\n    ENTSO-e Energy Rate is an FIBARO QuickApp that get current Spot prices for almost every european countries and is independent from any energy power company for free.\n\n    How to get your own Token:\n    IÂ´ve provide an Token that works \"out of the box\", but can be changed in the future, so if you like you can create your own free token at ENTSO-e, but not required.\n    Register an ENTSO-e account at: https://transparency.entsoe.eu/\n    How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf\n\n    The Exchange rate service (https://exchangerate.host) that is used in this QuickApp to get your local currency is also free to use and if you like it, donate a cappuccino at https://exchangerate.host/#/donate ;)\n\n    This is the first time I have developed in Lua language, so have some indulgence, but hey it works and I hope it works for U 2 ;)\n    I would appreciate if you have any feedback or suggestions to make this QuickApp more usefull, please send me an email at energyrate@jamdata.com and IÂ´ll try to do my best :)\n\n    Changelog:\n    v1.0 First release 2023-01\n    \n    v1.1 New feature release 2023-03\n        - Keeps Tariff rate history in FIBARO.\n        - Show more usefull info in QA panel.\n        - Add new global month average level variable \"EnergyMonthLevel\" for those that pay energy consumtion per month average.\n        - Add new QA variable \"TariffHistory\" for how many days to store history in FIBARO tariff rates.\n        - Localized panel text for language: EN, DK, NO, SV (if you want to help me with translation, please send me an email at energyrate@jamdata.com)\n\n        Braking changes that you need to change in your scenes if your using first release v1.0:\n            Global variable name change from \"EnergyRateArea\" to \"EnergyArea\".\n            Global variable name change from \"EnergyRateMedium\" to \"EnergyMediumPrice\".\n            Global variable name change from \"EnergyRateLevel\" to \"EnergyHourLevel\".\n            Global variable name change from \"EnergyRateNextLevel\" to \"EnergyNextHourLevel\".\n\n    v1.2 Customer wishes release 2023-04\n        - Option to add tax to the energy price.\n        - Show if service error message.\n\n    v1.3 Customer improvements 2023-05\n        - Rewrite energy tariff table to store in global variable instead of FIBARO tariff table to solve negative energy prices.\n        - Correct UTC time when request next day energy prices from ENTSO-e.\n        - Improved energy value display formatting, with price decimal local variable, also show correct price if very low or negative price. (Except FIBARO tariff that can't show negative values)\n        - All the rate levels are now set as local variables in real local energy price.\n        - Removed the global variable \"EnergyMediumPrice\", medium price is now set between Low and High prices in QA variables.\n        - Move global variable \"EnergyTaxPercentage\" to local variable as \"EnergyTax\".\n        - Add global variable ON/OFF to store prices in FIBARO Tariff rate table.\n        - Add translation in Portuguese (Thanks to Leandro C.).\n        - New variables to cost calculation formula: {[(ENTSO_cost + deviation cost) x losses x adjustment] + dealer + localgrid} x tax (Leandro C.).\n]]\n\nfunction QuickApp:onInit()\n    self.debugOn = false -- Write to debug console true/false\n    self.httpClient = net.HTTPClient()\n    \n    -- Variables for exchangerate.host Api service\n    -- https://exchangerate.host\n    self.exchangerate_baseURL = \"https://api.exchangerate.host/\"\n    self.exchangeRate = 1       -- Set default excahnge rate 1:1 for â‚¬\n\n    -- Variables for ENTSO-e Transparency Platform Api service\n    -- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html\n    self.entsoe_baseURL = \"https://web-api.tp.entsoe.eu/api\"\n    self.child_rank_name = \"ENTSO-e Next Energy Rate\"                   -- Name of next energy price QA child\n    self.next_rank_device_id = nil                                      -- Id of next energy price QA child\n\n    -- NOTE! Local QA variable names can only have maximun of 15 charachters\n    self.variable_token_name = \"ENTSOE_Token\"\n    self.variable_tariff_history_name = \"TariffHistory\"\n    self.variable_Low_name = \"PriceLow\"\n    self.variable_Medium_name = \"PriceMedium\"\n    self.variable_High_name = \"PriceHigh\"\n    self.variable_VeryHigh_name = \"PriceVeryHigh\"\n    self.variable_tax_percentage_name = \"EnergyTax\"\n    self.variable_price_decimals_name = \"PriceDecimals\"                 -- Variable name of number of decimals when display energy prices\n\n    self.variable_operator_cost_name = \"OperatorCost\"                   -- Variable name of Grid Operator deviation costs (â‚¬/kWh or â‚¬/MWh)\n    self.variable_grid_losses_name = \"GridLossesPct\"                    -- Variable name of Grid Losses percent cost (%)\n    self.variable_grid_adjustment_name = \"AdjustmentPct\"                -- Variable name of Grid Adjustment percent cost added to the Grid Losses (%)\n    self.variable_dealer_cost_name = \"DealerFee\"                        -- Variable name of Dealer fee cost (â‚¬/KWh or â‚¬/MWh)\n    self.variable_grid_cost_name = \"LocalGridCost\"                      -- Variable name of Local Grid cost (â‚¬/KWh or â‚¬/MWh)\n\n    -- Global variable names\n    self.global_var_unit_name = \"EnergyUnit\"                            -- Global variable name of energy unit (KWh or MWh)\n    self.global_var_state_table_name = \"EnergyStateTable\"               -- Global variable name of energy state table\n    self.global_var_area_name = \"EnergyArea\"\n    self.global_var_level_name = \"EnergyHourLevel\"\n    self.global_var_next_level_name = \"EnergyNextHourLevel\"\n    self.global_var_month_level_name = \"EnergyMonthLevel\"\n    self.global_var_fibaro_tariff_name = \"EnergyTariffInFibaro\"\n    \n    -- Default values to set if missing\n    self.default_token = \"f442d0b3-450b-46d7-b752-d8d692fdb2c8\"         -- See \"How to get your own Token:\" above.\n    self.default_area_name = \"Sweden (SE3)\"                             -- Could not come up with better default then my Area :)\n    self.default_unit = \"kWh\"                                           -- Show kWh or MWh in display panel (FIBARO Tariff table is always in kWh)\n    self.default_tax = \"0\"                                              -- Default 0% energy tax\n    self.default_tariff_history = \"62\"                                  -- Default 62 days ~2 month\n\n    self.default_decimals = self:getDefaultPriceDecimals()              -- Get default number of decimals based on currency for prices display\n    self.default_Low_price = self:getDefaultRatePrice(10)               -- 10% of medium price based on local currency\n    self.default_High_price = self:getDefaultRatePrice(160)             -- 160% of medium price based on local currency\n    self.default_VeryHigh_price = self:getDefaultRatePrice(250)         -- 250% of medium price based on local currency\n    \n    self.default_operator_cost = \"0\"                                    -- Default Grid Operator costs (0 â‚¬/kWh or 0 â‚¬/MWh)\n    self.default_grid_losses = \"0\"                                      -- Default Grid Losses in percent (0 %)\n    self.default_grid_adjustment = \"0\"                                  -- Default adjustment added to the Grid Losses in percent (0 %)\n    self.default_dealer_cost = \"0\"                                      -- Default Dealer cost (0 â‚¬/KWh or 0 â‚¬/MWh)\n    self.default_grid_cost = \"0\"                                        -- Default Local Grid cost (0 â‚¬/KWh or 0 â‚¬/MWh)\n\n    -- Fixed QA variables\n    self.nextday_releaseTime = 12                                       -- The UTC time of the day when ENTSO-e usually releses the next day prices\n    self.dateFormat = self:getDateFormat()                              -- The FIBARO Date format setting (\"YY-MM-DD\", \"DD.MM.YY\" or \"MM/DD/YY\") that will be converted to Lua date format\n    self.valueFormat = self:getValueFormat(self.default_decimals)       -- The value formatting of decimals when display Energy prices ie. \"%.2f\"\n    self.serviceRequestTime = \"--\"                                      -- Last datetime when we request ENTSO-e webservice.\n    self.serviceSuccess = true                                          -- Request ENTSO-e service success or fault\n    self.serviceMessage = \"\"                                            -- Request ENTSO-e service error message\n    \n    -- LetÂ´s start\n    self:mainStart()\nend\n\nfunction QuickApp:mainStart()\n    -- Create global varaiables and set default values (See: defaults)\n    self:createAreaVariables()    \n    self:createGlobalVariables()\n    self:setLocalVariables()\n            \n    -- Init Child device to display next hour rate in FIBARO (See: QAChild_NextRank)\n    self:initChildDevices({[\"com.fibaro.multilevelSensor\"] = ENTSOE_Next_Rank})\n    self:validateChildren()\n    \n    -- Start loop, one for request ENTSO-e service and exchange rate and one for updating global variables and panel display.\n    self:d(\">>>> Start ENTSO-e Energy Rate <<<<\")\n    self:serviceRequestLoop(false) -- Request ExchangeRate and ENTSO-e services\nend\n\n-- Trigger if panel refresh button pressed\nfunction QuickApp:refresh_action()\n    self:d(\"Execute ENTSO-e service update on button event...\")\n    self:updateView(\"refreshButton\", \"text\", \"âŒ› \" ..self.i18n:get(\"Refreshing\") ..\"...\")\n    self:serviceRequestLoop(true)\nend\n\n-- ENTSO-e and Exchange rate service loop\nfunction QuickApp:serviceRequestLoop(forceUpdate)\n    -- Set Update service request loop to every hour\n    local loopTime = (tonumber(os.date(\"%M\"))) * 60 * 1000\n   \n    -- Get current Exchange rate from Exchangerate.host Api Service\n    local waitTime = 0\n    self.exchangeRateUpdated = true\n    if (self.currency ~= \"EUR\") then -- If local currency already in Euro we don't need exchange rates.\n        self:getServiceExchangeData(QuickApp.setExchangeRate, self)\n        waitTime = 2000\n    end\n\n    -- Refresh variables\n    self:refreshVariables()\n\n    -- Check if table is already up to date, otherwise request service and update table  \n    if forceUpdate or not self:IsEnergyTariffUpToDate() then\n        -- Get Energy Rates from ENSO-e Service (only wait 2 sec for Exchange rate http request to complete if currency not in EUR)\n        fibaro.setTimeout(waitTime, function() self:updateTariffData() end)\n    end\n\n    -- Start this Service request loop\n    fibaro.setTimeout(loopTime, function() self:serviceRequestLoop() end)\n\n    -- Update variables and panel\n    self:displayLoop(true) \nend\n\nfunction QuickApp:updateTariffData()\n    -- Get current day energy rates.\n    -- ENTSO-e service only returns 24 hour Rates on each request even if we define another \"toDate\" :(\n    self:getServiceRateData(QuickApp.updateEnergyTariffTable, self, os.date(\"%Y%m%d0000\"), os.date(\"%Y%m%d2300\"), true)\n    \n    -- Get next 24 hour energy rates if they have been released, normally the next day energy rates are released after 12:00 UTC.\n    -- We also need the next day rates to solve the midnight shift between 23:00 and 00:00.\n    if (self.serviceSuccess and tonumber(os.date(\"%H\", os.time())) >= self:getRateReleaseTime(self.timezoneOffset)) then\n        fibaro.setTimeout(2000, function() \n                                    self:getServiceRateData(QuickApp.updateEnergyTariffTable, self, os.date(\"!%Y%m%d0000\", os.time() + 86400), os.date(\"!%Y%m%d2300\", os.time() + 86400), false) \n                                end)\n    end\n    \n    self.serviceRequestTime = os.date(self:getDateFormat()) ..\" \" ..os.date(\"%H:%M\")\nend\n\n-- Variables and panel update display loop\nfunction QuickApp:displayLoop(first)\n    -- Set Update display loop to every full hour + 1 min\n    local loopTime = 10000\n    if not first then loopTime = (61 - tonumber(os.date(\"%M\"))) * 60 * 1000 end\n\n     -- Refresh variable values\n    self:refreshVariables()\n\n    -- Update FIBARO Tariff table if ON\n    --if self.storeTariffInFibaro == true then self:updateFibaroTariffTable() end\n    self:updateFibaroTariffTable()\n\n    -- Start this display loop each hour\n    fibaro.setTimeout(loopTime, function() self:displayLoop(false) end)\nend"},{"name":"QAChild_NextRank","isMain":false,"isOpen":false,"content":"function QuickApp:validateChildren()\r\n    self:d(\"Validate QuickApp Children\")\r\n    for id,device in pairs(self.childDevices) do\r\n        self:d(tostring(id) .. \" = \" .. device.name)\r\n\r\n        if (device.name == self.child_rank_name) then\r\n            self.next_rank_device_id = id\r\n            self:d(tostring(id) .. \" - child_rank_name: \" .. device.name)\r\n        end\r\n    end\r\n\r\n    if self.next_rank_device_id == nil then\r\n        self:d(\"Create QuickApp Children\")\r\n        self:createRankChild()\r\n    end\r\nend\r\n\r\nfunction QuickApp:createRankChild()\r\n    local child = self:createChildDevice({\r\n        name = self.child_rank_name,\r\n        type = \"com.fibaro.multilevelSensor\",\r\n    }, ENTSOE_Next_Rank)\r\n    self.next_rank_device_id = child.id\r\nend\r\n\r\n\r\nclass 'ENTSOE_Next_Rank' (QuickAppChild)\r\nfunction ENTSOE_Next_Rank:__init(device)\r\n    -- You should not insert code before QuickAppChild.__init.\r\n    QuickAppChild.__init(self, device) -- We must call a constructor from the parent class\r\n    self:updateProperty(\"unit\", \"\")\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setValue(value)\r\n    self:updateProperty(\"value\", value)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setUnit(unit)\r\n    self:updateProperty(\"unit\", unit)\r\nend\r\n\r\nfunction ENTSOE_Next_Rank:setLog(log)\r\n    self:updateProperty(\"log\", log)\r\nend\r\n"},{"name":"functions","isMain":false,"isOpen":false,"content":"-- Write to console if debug=true\r\nfunction QuickApp:d(msg)\r\n    if self.debugOn then self:debug(msg) end\r\nend\r\n\r\n-- Get Energy Tariff table from global variable\r\nfunction QuickApp:getEnergyTariffTable()\r\n    local tariffData = {}\r\n    local jsonString = fibaro.getGlobalVariable(self.global_var_state_table_name)\r\n    \r\n    -- Create global variable if missing\r\n    if (jsonString == nil) then self:createGlobalVariableTable() end\r\n\r\n    -- Decode json string to table\r\n    if (jsonString ~= nil and jsonString ~= \"\") then \r\n        tariffData = json.decode(jsonString)\r\n    end\r\n\r\n    return tariffData\r\nend\r\n\r\n-- Get currency symbol\r\nfunction QuickApp:getCurrencySymbol()\r\n    local currency = self.currency\r\n    if (currency == \"EUR\") then return \"â‚¬\" end\r\n    if (currency == \"USD\") then return \"$\" end\r\n    if (currency == \"GBP\") then return \"Â£\" end\r\n    if (currency == \"YEN\") then return \"Â¥\" end\r\n    return currency\r\nend\r\n\r\n-- Get Lua date format from FIBARO date format\r\nfunction QuickApp:getDateFormat()\r\n    if self.dateFormat == \"YY-MM-DD\" then return \"%Y-%m-%d\" end\r\n    if self.dateFormat == \"DD.MM.YY\" then return \"%d.%m.%Y\" end\r\n    if self.dateFormat == \"MM/DD/YY\" then return \"%m/%d/%Y\" end\r\n    return \"%Y-%m-%d\"\r\nend\r\n\r\n-- Get value format\r\nfunction QuickApp:getValueFormat()\r\n    if (self.decimals == nil) then self.decimals = self:getDefaultPriceDecimals() end\r\n    return \"%.\" ..tostring(self.decimals) ..\"f\"\r\nend\r\n\r\nfunction QuickApp:toLocalDateId(dateString, addHour, timezoneOffset)\r\n    if dateString == \"\" then return \"\" end\r\n    if addHour == nil then addHour = 0 end\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n    -- Convert input dateString = \"2022-12-25 23:00\" to table Id date \"22122523\"\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+) (%d+):(%d+)\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute}) + timezoneOffset\r\n    return os.date(\"%y%m%d%H\", timestamp + (addHour * 60 * 60))\r\nend\r\n\r\nfunction QuickApp:toDate(dateId, format, addHour)\r\n    if dateId == \"\" then return \"\" end\r\n    if format == nil then format = \"%Y-%m-%d %H:%M\" end\r\n    if addHour == nil then addHour = 0 end\r\n    -- Convert input dateId = \"22122523\" to Lua date format\r\n    local iyear, imonth, iday, ihour = dateId:match(\"^(%d%d)(%d%d)(%d%d)(%d%d)$\")\r\n    local timestamp = os.time({year = iyear + 2000, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp + (addHour * 60 * 60))\r\nend\r\n\r\n-- Get ENTSO-e next day price release date in local time\r\nfunction QuickApp:getRateReleaseTime(timezoneOffset)\r\n    if timezoneOffset == nil then timezoneOffset = 0 end\r\n    return tonumber(os.date(\"!%H\", os.time({year=2000, month=1, day=1, hour=self.nextday_releaseTime, min=0}) + timezoneOffset))\r\nend\r\n\r\n-- Count items in a Lua table\r\nfunction QuickApp:tableCount(T)\r\n    local count = 0\r\n    if T == nil or T == \"\" then return count end\r\n    for _ in pairs(T) do count = count + 1 end\r\n    return count\r\nend\r\n\r\n-- Convert xml input dateString = \"2022-12-25T23:00Z\" to Lua date\r\nfunction QuickApp:getXmlDate(xmlString, name, format)\r\n    local dateString = self:getXmlElement(xmlString, name)\r\n    local iyear, imonth, iday, ihour, iminute = dateString:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+)Z\")\r\n    local timestamp = os.time({year = iyear, month = imonth, day = iday, hour = ihour, min = iminute})\r\n    return os.date(format, timestamp)\r\nend\r\n\r\n-- Get xml element value\r\nfunction QuickApp:getXmlElement(data, name)\r\n    return data:match(\"<\"..name..\">(.-)</\"..name..\">\")\r\nend\r\n\r\n-- Extract ENTSO-e prices from response xml into Lua table\r\nfunction QuickApp:xml2PriceTable(xml)\r\n    local priceTable = {}\r\n    local ni, c, label, xarg, empty\r\n    local i, j = 1, 1\r\n\r\n    while true do\r\n        ni, j, c, label, xarg, empty = string.find(xml, \"<(%/?)([%w:_]+)(.-)(%/?)>\", i)\r\n        if not ni then break end\r\n        local text = string.sub(xml, i, ni-1)\r\n   \r\n        if not string.find(text, \"^%s*$\") and label == \"price\" then\r\n            table.insert(priceTable, text)\r\n        end\r\n\r\n        i = j+1\r\n    end\r\n\r\n    return priceTable\r\nend\r\n\r\nfunction QuickApp:getLocalTariffRate(rawRate, exchangeRate, unit, tax, operator, losses, adjustment, dealer, grid)\r\n    if (exchangeRate == nil) then exchangeRate = 1 end\r\n    if (tax == nil or tax == 0) then tax = 1 end\r\n    if (tax > 1) then tax = (tax / 100) + 1 end -- Convert input tax from % to decimal if > 1\r\n    \r\n    if (operator == nil) then operator = 0 end\r\n    if (losses == nil or losses == 0) then losses = 1 end\r\n    if (losses > 1) then losses = (losses / 100) + 1 end -- Convert input losses in % to decimal if > 1\r\n    if (adjustment == nil or adjustment == 0) then adjustment = 1 end\r\n    if (adjustment > 1) then adjustment = (adjustment / 100) + 1 end -- Convert input adjustment in % to decimal if > 1\r\n    if (dealer == nil) then dealer = 0 end\r\n    if (grid == nil) then grid = 0 end\r\n\r\n    -- Get Unit scale. ENTSO-e always return prices in â‚¬/MWh\r\n    local unitScale = 1000 -- kWh\r\n    if (unit == \"MWh\") then unitScale = 1 end \r\n    \r\n    -- Recalculate main rate from EUR/mWh to {local currency}/{MWh or kWh} * tax\r\n    local rate = string.format(\"%f\", ((((((rawRate * exchangeRate) / unitScale) + operator) * losses * adjustment) + dealer + grid) * tax))\r\n    return tonumber(rate)\r\nend\r\n\r\nfunction QuickApp:getRank(value)\r\n    -- Set defaults if not valid input value\r\n    if (value == nil or value == \"nan\" or value == \"--\") then return \"\" end\r\n    value = tonumber(value)\r\n\r\n    -- Return price rank from variable rank values\r\n    local rank = \"VeryLOW\"\r\n    if (value >= self.low_price) then rank = \"LOW\" end\r\n    if (value >  self.low_price and value < self.high_price) then rank = \"MEDIUM\" end\r\n    if (value >= self.high_price) then rank = \"HIGH\" end\r\n    if (value >= self.veryhigh_price) then rank = \"VeryHIGH\" end\r\n\r\n    self:d(\"Set the rank level value \" ..value ..\" = \" ..rank)\r\n\r\n    return rank\r\nend\r\n\r\nfunction QuickApp:getRankIcon(value)\r\n    if (value == \"VeryHIGH\") then return \"ðŸ”´\" end\r\n    if (value == \"HIGH\") then return \"ðŸŸ \" end\r\n    if (value == \"MEDIUM\") then return \"ðŸŸ¡\" end\r\n    if (value == \"LOW\") then return \"ðŸ”µ\" end\r\n    if (value == \"VeryLOW\") then return \"ðŸŸ¢\" end\r\n    return \"â›”\" -- Wrong value\r\nend\r\n\r\nfunction QuickApp:getNextDirection(currentValue, nextValue)\r\n    if (currentValue == nil) then currentValue = 0 end\r\n    if (nextValue == nil) then nextValue = 0 end\r\n    if (currentValue > nextValue) then return \"â‡©\" end\r\n    if (currentValue < nextValue) then return \"â‡§\" end\r\n    return \"â‡¨\"\r\nend"},{"name":"defaults","isMain":false,"isOpen":true,"content":"function QuickApp:createGlobalVariableTable()\r\n    -- Create Energy state table global variable\r\n    local table_var = {\r\n            name=self.global_var_state_table_name,\r\n            isEnum=false,\r\n            readOnly=true,\r\n            value=\"\"\r\n        }\r\n    api.post('/globalVariables/', table_var)\r\nend\r\n\r\nfunction QuickApp:createGlobalVariables()\r\n    -- Create Energy store in FIBARO Tariff global variable\r\n    local tariff_var = {\r\n            name=self.global_var_fibaro_tariff_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"ON\",\r\n            enumValues={\"ON\",\"OFF\"}\r\n        }\r\n    api.post('/globalVariables/', tariff_var)\r\n\r\n    -- Create Energy Unit global variable\r\n    local unit_var = {\r\n            name=self.global_var_unit_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_unit,\r\n            enumValues={\"kWh\",\"MWh\"}\r\n        }\r\n    api.post('/globalVariables/', unit_var)\r\n\r\n    -- Create Level rate global variable\r\n    local level_var = {\r\n            name=self.global_var_level_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=\"HIGH\",\r\n            enumValues={\"VeryLOW\",\"LOW\",\"MEDIUM\",\"HIGH\",\"VeryHIGH\"}\r\n        }\r\n    api.post('/globalVariables/', level_var)\r\n\r\n    -- Create Next Level rate global variable\r\n    level_var.name = self.global_var_next_level_name\r\n    api.post('/globalVariables/', level_var)\r\n\r\n    -- Create Month Level rate global variable\r\n    level_var.name = self.global_var_month_level_name\r\n    api.post('/globalVariables/', level_var)\r\n\r\n    self:d(\"FIBARO Global variables crated.\")\r\nend\r\n\r\nfunction QuickApp:setLocalVariables()\r\n    -- Not required, but you can register and create your own account and get a token at ENTSO-e.\r\n    -- Register an free ENTSO-e account at: https://transparency.entsoe.eu/\r\n    -- How to get an Token: https://transparency.entsoe.eu/content/static_content/download?path=/Static%20content/API-Token-Management.pdf \r\n    self.token = self:getLocalVariable(self.variable_token_name, self.default_token)\r\n\r\n    -- Get/Set local rate price variables\r\n    self.low_price = self:getLocalVariable(self.variable_Low_name, self.default_Low_price)\r\n    self.high_price = tonumber(self:getLocalVariable(self.variable_High_name, self.default_High_price))\r\n    self.veryhigh_price = tonumber(self:getLocalVariable(self.variable_VeryHigh_name, self.default_VeryHigh_price))\r\n\r\n    -- Get/Set local variable price decimals\r\n    self.decimals = self:getLocalVariable(self.variable_price_decimals_name, self.default_decimals)\r\n    -- Get/Set local variable Days to keep FIBARO Tariff history\r\n    self.tariffHistory = self:getLocalVariable(self.variable_tariff_history_name, self.default_tariff_history)\r\n    -- Get/Set local variable tax\r\n    self.tax = self:getLocalVariable(self.variable_tax_percentage_name, self.default_tax)\r\n    \r\n    -- Get/Set local variable operator cost\r\n    self.operatorCost = self:getLocalVariable(self.variable_operator_cost_name, self.default_operator_cost)\r\n    -- Get/Set local variable grid losses in percent\r\n    self.gridLosses = self:getLocalVariable(self.variable_grid_losses_name, self.default_grid_losses)\r\n    -- Get/Set local variable grid adjustment in percent\r\n    self.gridAdjustment = self:getLocalVariable(self.variable_grid_adjustment_name, self.default_grid_adjustment)\r\n    -- Get/Set local variable dealer cost\r\n    self.dealerCost = self:getLocalVariable(self.variable_dealer_cost_name, self.default_dealer_cost)\r\n    -- Get/Set local variable grid cost\r\n    self.gridCost = self:getLocalVariable(self.variable_grid_cost_name, self.default_grid_cost)\r\n\r\n    -- Get/Set global FIBARO variables\r\n    self.areaName = self:getGlobalFibaroVariable(self.global_var_area_name, self.default_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self.unit = self:getGlobalFibaroVariable(self.global_var_unit_name, self.default_unit)\r\n\r\n    self:refreshVariables()\r\nend\r\n\r\nfunction QuickApp:refreshVariables()\r\n    -- Get FIBARO settings\r\n    local fibaroSettings = api.get(\"/settings/info\")\r\n    self.currency = fibaroSettings.currency\r\n    self.timezoneOffset = tonumber(fibaroSettings.timezoneOffset)\r\n    self.dateFormat = fibaroSettings.dateFormat\r\n    self.i18n = i18n:new(fibaroSettings.defaultLanguage)\r\n    \r\n    -- Refrech global variables\r\n    self.areaName = fibaro.getGlobalVariable(self.global_var_area_name)\r\n    self.areaCode = self:getAreaCode(self.areaName)\r\n    self.tariffData = self:getEnergyTariffTable()\r\n    self.unit = fibaro.getGlobalVariable(self.global_var_unit_name) \r\n\r\n    -- Refresh QA variable values\r\n    self.token = self:getVariable(self.variable_token_name)\r\n    self.tariffHistory = tonumber(self:getVariable(self.variable_tariff_history_name))\r\n    self.low_price = tonumber(self:getVariable(self.variable_Low_name))\r\n    self.high_price = tonumber(self:getVariable(self.variable_High_name))\r\n    self.veryhigh_price = tonumber(self:getVariable(self.variable_VeryHigh_name))\r\n    self.tax = tonumber(self:getVariable(self.variable_tax_percentage_name))\r\n    self.decimals = self:getVariable(self.variable_price_decimals_name)\r\n    self.valueFormat = self:getValueFormat()\r\n\r\n    self.operatorCost = tonumber(self:getVariable(self.variable_operator_cost_name))\r\n    self.gridLosses = tonumber(self:getVariable(self.variable_grid_losses_name))\r\n    self.gridAdjustment = tonumber(self:getVariable(self.variable_grid_adjustment_name))\r\n    self.dealerCost = tonumber(self:getVariable(self.variable_dealer_cost_name))\r\n    self.gridCost = tonumber(self:getVariable(self.variable_grid_cost_name))\r\n\r\n    self:updateProperty(\"unit\", self.currency .. \"/\" ..self.unit)\r\n\r\n    -- Set Energy rates data to display\r\n    self:displayEnergyRate()\r\nend\r\n\r\n-- Get local QA variable, set to default value if variable is missing\r\nfunction QuickApp:getLocalVariable(name, defaultValue)\r\n    local value = self:getVariable(name)\r\n\r\n    if (value == nil or value == \"\" or value == \"nil\") then\r\n        self:setVariable(name, tostring(defaultValue))\r\n        return defaultValue\r\n    else\r\n        return value\r\n    end\r\nend\r\n\r\n-- Get local QA variable, set to default value if variable is missing\r\nfunction QuickApp:getGlobalFibaroVariable(name, defaultValue)\r\n    local value = fibaro.getGlobalVariable(name)\r\n\r\n    if (value == nil or value == \"\" or value == \"nil\") then\r\n        fibaro.setGlobalVariable(name, tostring(defaultValue))\r\n        return defaultValue\r\n    else\r\n        return value\r\n    end\r\nend\r\n\r\n-- Get default rate price based in local currency\r\nfunction QuickApp:getDefaultPriceDecimals()\r\n    if (self.currency == nil or self.currency == \"\") then\r\n        local fibaroSettings = api.get(\"/settings/info\")\r\n        self.currency = fibaroSettings.currency\r\n    end\r\n\r\n    -- TODO: do an more accurat difference between currencies\r\n    if (self.currency == \"EUR\" or self.currency == \"USD\" or self.currency == \"GBP\") then\r\n        return \"5\"\r\n    else\r\n        return \"3\"\r\n    end\r\nend\r\n\r\n-- Get default rate price based in local currency\r\nfunction QuickApp:getDefaultRatePrice(percent)\r\n    if (self.currency == nil or self.currency == \"\") then\r\n        local fibaroSettings = api.get(\"/settings/info\")\r\n        self.currency = fibaroSettings.currency\r\n    end\r\n\r\n    -- TODO: do an more accurat difference between currencies\r\n    if (self.currency == \"EUR\" or self.currency == \"USD\" or self.currency == \"GBP\") then\r\n        return tostring(0.2 * (percent / 100))\r\n    else\r\n        return tostring(1 * (percent / 100))\r\n    end\r\nend"},{"name":"display","isMain":false,"isOpen":true,"content":"function QuickApp:displayEnergyRate()   \r\n    -- Get current Fibaro Tariff Data\r\n    local tariffData = self:getEnergyRateData()\r\n    \r\n    -- Calculate values\r\n    local rank = self:getRank(tariffData.currentRate)\r\n    local nextRank = self:getRank(tariffData.nextRate)\r\n    local nextDir = self:getNextDirection(tariffData.currentRate, tariffData.nextRate)\r\n    local prevDir = self:getNextDirection(tariffData.previousRate, tariffData.currentRate)\r\n    local rateDiff = string.format(self.valueFormat, tariffData.nextRate - tariffData.currentRate)\r\n    local prevDiff = string.format(self.valueFormat, tariffData.currentRate - tariffData.previousRate)\r\n\r\n    -- Set dafaults\r\n    local avgRate = 0\r\n    local avgRank = \"\"\r\n    local refresh = \"â™»ï¸\"\r\n    local serviceUpdated = refresh\r\n    local lastRqt = refresh ..self.i18n:get(\"LoadingEnergyRates\") ..\"ï¸...\"\r\n    local lastUpd = refresh ..self.i18n:get(\"Refreshing\") ..\"ï¸...\"\r\n    local areaName = self.areaName\r\n\r\n    -- Set Exchange rate\r\n    local exchangeRate = \"--\"\r\n    if (self.exchangeRate > 0) then exchangeRate = string.format(self.valueFormat, self.exchangeRate) end\r\n    \r\n    -- If Service request failed\r\n    if self.serviceSuccess == false then\r\n        lastRqt = \"n/a\"\r\n        lastUpd = \"n/a\"\r\n        areaName = areaName ..\"\\nâš ï¸ \" ..self.i18n:get(\"MissingEnergyRatesForSelectedArea\")\r\n        if (self.serviceMessage ~= \"\") then areaName = areaName ..\"\\nâ›” \" ..self.serviceMessage ..\"\\n\" end\r\n    end\r\n\r\n    -- Only update variables and tariff if we got \"real\" rate data\r\n    if tariffData.energyPricesUpdated == true and self.exchangeRateUpdated == true then\r\n        avgTotalRank = self:getRank(tariffData.avgTotalRate)\r\n        avgDayRank = self:getRank(tariffData.avgDayRate)\r\n        avgMonthRank = self:getRank(tariffData.avgMonthRate)\r\n\r\n        self:updateProperty('value', tonumber(tariffData.currentRate))\r\n        self:updateProperty('log', self:getRankIcon(rank) ..rank)\r\n        \r\n        fibaro.setGlobalVariable(self.global_var_level_name, rank)        \r\n        fibaro.setGlobalVariable(self.global_var_next_level_name, nextRank)\r\n        fibaro.setGlobalVariable(self.global_var_month_level_name, avgMonthRank)\r\n\r\n        if (self.next_rank_device_id ~= nil) then\r\n            fibaro.call(self.next_rank_device_id, 'setLog', self:getRankIcon(nextRank) ..nextRank)\r\n            fibaro.call(self.next_rank_device_id, 'setUnit', \" \" .. nextDir)\r\n            fibaro.call(self.next_rank_device_id, 'setValue', rateDiff)\r\n        end\r\n        \r\n        serviceUpdated = self.serviceRequestTime\r\n        lastUpd = os.date(\"%Y-%m-%d %H:%M\")\r\n        self:updateView(\"refreshButton\", \"text\", self.i18n:get(\"Refresh\"))\r\n        refresh = \"\"\r\n        \r\n        self:d(\"Display panels updated: \" ..os.date(\"%H:%M:%S\"))\r\n    end\r\n\r\n    -- Update FIBARO Info panel\r\n    local labelInfo = self.i18n:get(\"TodayRates\") ..\" (\" ..self.i18n:get(\"Range\") ..\": \" ..tariffData.minDayRate ..\"--\" ..tariffData.maxDayRate ..\" \" ..self:getCurrencySymbol() ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(rank) ..\" \" ..self.i18n:get(\"CurrentHour\") ..\": \" ..tariffData.currentRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..prevDiff ..\" \" ..prevDir ..\") - \" ..self.i18n:get(rank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(nextRank) ..\" \" ..self.i18n:get(\"NextHour\") ..\": \" ..tariffData.nextRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..rateDiff ..\" \" ..nextDir ..\") - \" ..self.i18n:get(nextRank) ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgDayRank) ..\" \" ..self.i18n:get(\"TodayAverage\") ..\": \" .. tariffData.avgDayRate ..\" \" ..self:getCurrencySymbol() ..\" - \" ..self.i18n:get(avgDayRank) ..\"\\n\\n\"\r\n\r\n    if (tariffData.nextDayRate == true) then\r\n        local avgNextDayRank = self:getRank(tariffData.avgNextDayRate)\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRateRange\") ..\": \" ..tariffData.minNextDayRate ..\"--\" ..tariffData.maxNextDayRate ..\" \" ..self:getCurrencySymbol() ..\"\\n\"\r\n        labelInfo = labelInfo ..self:getRankIcon(avgNextDayRank) ..\" \" ..self.i18n:get(\"TomorrowAverage\") ..\": \" ..tariffData.avgNextDayRate ..\" \" ..self:getCurrencySymbol() ..\" - \" ..self.i18n:get(avgNextDayRank) ..\"\\n\\n\"\r\n    else\r\n        labelInfo = labelInfo ..self.i18n:get(\"TomorrowRatesReleases\") ..\" \" ..self:getRateReleaseTime(self.timezoneOffset) ..\":00 (UTC: \" ..self.nextday_releaseTime ..\":00)\\n\"\r\n        labelInfo = labelInfo ..\"ðŸ•“ \" ..self.i18n:get(\"TomorrowAverage\") ..\": --\\n\\n\"\r\n    end\r\n\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRatePeriod\") ..\": \" ..tariffData.firstDate ..\"--\" ..tariffData.lastDate ..\"\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgMonthRank) ..\" \" ..self.i18n:get(\"ThisMonthAverage\") .. \": \" ..tariffData.avgMonthRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..string.format(\"%.0f\", tariffData.avgMonthCount/24) ..\" \" ..self.i18n:get(\"Days\") ..\")\\n\"\r\n    labelInfo = labelInfo ..self:getRankIcon(avgTotalRank) ..\" \" ..self.i18n:get(\"TotalTariffAverage\") .. \": \" ..tariffData.avgTotalRate ..\" \" ..self:getCurrencySymbol() ..\" (\" ..string.format(\"%.0f\", tariffData.count/24) ..\" \"  ..self.i18n:get(\"Days\") ..\")\" ..\"\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyArea\") ..\": \" ..areaName ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"AreaCode\") ..\": \" ..self.areaCode ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"TariffRateHistory\") ..\": \" ..self.tariffHistory ..\" \" ..self.i18n:get(\"days\") ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"MediumRatePrice\") ..\": \" ..self.low_price ..\"--\" ..self.high_price ..\" \" ..self:getCurrencySymbol() ..\"/\" ..self.unit ..\"\\n\"\r\n\r\n    labelInfo = labelInfo ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"EnergyRateUpdate\") ..\": \" ..serviceUpdated ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"VariableUpdate\") ..\": \" ..lastUpd ..\"\\n\"\r\n    labelInfo = labelInfo ..self.i18n:get(\"FibaroTariff\") ..\": \" ..fibaro.getGlobalVariable(self.global_var_fibaro_tariff_name) ..\"\\n\"\r\n\r\n    -- Only show if Tax value is set\r\n    if (self.tax ~= nil and self.tax > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"Tax\") ..\": \" ..string.format(\"%.2f\", self.tax) ..\"%\"\r\n    end\r\n\r\n    -- Only show if Operator value is set\r\n    if (self.operatorCost > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"OperatorCost\") ..\": \" ..self.operatorCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n    -- Only show if Losses value is set\r\n    if (self.gridLosses > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridLosses\") ..\": \" ..string.format(\"%.2f\", self.gridLosses) ..\"%\"\r\n    end\r\n    -- Only show if Adjustment value is set\r\n    if (self.gridAdjustment > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridAdjustment\") ..\": \" ..string.format(\"%.2f\", self.gridAdjustment) ..\"%\"\r\n    end\r\n    -- Only show if Dealer value is set\r\n    if (self.dealerCost > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"DealerCost\") ..\": \" ..self.dealerCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n    -- Only show if Grid value is set\r\n    if (self.gridCost > 0) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"GridCost\") ..\": \" ..self.gridCost ..\" \" ..self:getCurrencySymbol() ..\"/\"..self.unit\r\n    end\r\n\r\n    -- Only show if exchange currency is not in Euro\r\n    if (self.currency ~= \"EUR\") then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..refresh ..self.i18n:get(\"ExchangeRate\") ..\": 1 â‚¬ = \" ..exchangeRate ..\" \" ..self:getCurrencySymbol()\r\n    end\r\n    \r\n    -- If missing translation, just to trigger users to help me with translations ;)\r\n    if not (self.i18n.isTranslated) then\r\n        labelInfo = labelInfo ..\"\\n\"\r\n        labelInfo = labelInfo ..\"âš ï¸ \" ..self.i18n:get(\"MissingTranslation\") ..\": \" ..self.i18n.languageCode\r\n    end\r\n\r\n    self:updateView(\"labelInfo\", \"text\", labelInfo)\r\n\r\n    self:d(\"Current (\" ..self.i18n:get(rank) ..\") Rate: \" ..tariffData.currentRate ..\" \" ..self.currency ..\"/kWh, Next (\" ..nextRank ..\") Rate: \" ..tariffData.nextRate ..\" \" ..self.currency ..\"/kWh\" ..\" (\" ..rateDiff ..nextDir ..\")\")\r\nend"},{"name":"exchangeRate","isMain":false,"isOpen":false,"content":"-- Exchange rates API is a simple and lightweight free service for current and historical foreign exchange rates & crypto exchange rates.\r\n-- Reliable and up-to-date EU VAT rates, sourced directly from the European Commission's databases.\r\n-- If you like it, donate a cappuccino https://exchangerate.host/#/donate ;)\r\n\r\n-- Service home site: https://exchangerate.host\r\n\r\nfunction QuickApp:setExchangeRate(responseData)\r\n    if responseData == nil then\r\n        self:debug(\"Exchange Rate: Error when request rate!\")\r\n    end\r\n\r\n    for curr, value in pairs(responseData.rates) do\r\n        self.exchangeRateUpdated = true\r\n        self.exchangeRate = tonumber(value)\r\n        self:d(\"Exchange Rate: 1 EUR = \" .. value .. \" \" .. curr)\r\n    end\r\nend\r\n\r\nfunction QuickApp:getServiceExchangeData(callback, instance)\r\n    -- Request exchangerate.host with base currency \"EUR\" that always is ENTSO-e response currency\r\n    self.exchangeRateUpdated = false\r\n    local url = self.exchangerate_baseURL .. \"latest?base=EUR&symbols=\" .. self.currency .. \"&amount=1\"\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {[\"Accept\"] = \"application/json\"}\r\n        },\r\n        success = function(response)\r\n            local success, data = pcall(function()\r\n                                            return json.decode(response.data)\r\n                                        end)\r\n\r\n            if success then\r\n                pcall(callback, instance, data)\r\n            else\r\n                self:debug(\"Broken json response from Url: \" .. url)\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            self:debug(\"Error:\", message)\r\n            return nil\r\n        end\r\n    })\r\nend\r\n"},{"name":"entsoe_GetEnergyRate","isMain":false,"isOpen":true,"content":"-- https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_generation_domain\r\n-- 4.2.10. Day Ahead Rates [12.1.D]\r\n\r\nfunction QuickApp:getServiceRateData(callback, instance, fromdate, todate, reportError)\r\n    self:d(\"Request ENTSO-e for period UTC: \" .. fromdate .. \" -- \" .. todate .. \" (AreaCode: \" .. self.areaCode .. \")\")\r\n\r\n    local ratePrices = {}\r\n    local url = self.entsoe_baseURL .. \"?documentType=A44&in_Domain=\" .. self.areaCode .. \"&out_Domain=\" .. self.areaCode .. \"&periodStart=\" .. fromdate .. \"&periodEnd=\" .. todate .. \"&securityToken=\" .. self.token\r\n\r\n    self.httpClient:request(url, {\r\n        options = {\r\n            method = \"GET\",\r\n            headers = {\r\n                [\"SECURITY_TOKEN\"] = self.token,\r\n                [\"Accept\"] = \"text/xml\"\r\n            }\r\n        },\r\n        success = function(response)\r\n            -- Create Rate table from XML response\r\n            local periodXml = self:getXmlElement(response.data, \"Period\")\r\n            local success, data = pcall(function()\r\n                                            return self:xml2PriceTable(periodXml) -- Extact rate prices from XML\r\n                                        end)                                        \r\n            if success then\r\n                if data == nil then\r\n                    if (reportError == true) then\r\n                        self.serviceSuccess = false\r\n                        self.serviceMessage = \"ERROR: Empty response from Url \" ..url\r\n                        self:debug(self.serviceMessage)\r\n                    end\r\n                    return nil\r\n                end\r\n\r\n                -- Get UTC start and end date from response XML\r\n                local startDate = self:getXmlDate(periodXml, \"start\", \"%Y-%m-%d %H:%M\")\r\n                local endDate = self:getXmlDate(periodXml, \"end\", \"%Y-%m-%d %H:%M\")\r\n\r\n                -- Create (UTC) date and rate table\r\n                for index, rate in pairs(data) do\r\n                    local ratePrice = {\r\n                        id = self:toLocalDateId(startDate, index - 1, self.timezoneOffset),\r\n                        rate = tonumber(rate)\r\n                    }\r\n                    table.insert(ratePrices, ratePrice)\r\n                end\r\n\r\n                self:d(\"=> Response: Start UTC = \" .. startDate .. \", End UTC = \" .. endDate .. \", \" .. self:tableCount(ratePrices) .. \" rates\")\r\n                \r\n                self.serviceSuccess = true\r\n                self.serviceMessage = \"\"\r\n\r\n                pcall(callback, instance, ratePrices)\r\n            else\r\n                if (reportError == true) then\r\n                    self.serviceSuccess = false\r\n                    self.serviceMessage = \"Error: Can't get energy prices from ENTSO-e\"\r\n                    self:debug(self.serviceMessage)\r\n                end\r\n                return nil\r\n            end\r\n        end,\r\n        error = function(message)\r\n            if (reportError == true) then\r\n                self.serviceSuccess = false\r\n                self.serviceMessage = \"Error: \" ..message\r\n                self:debug(self.serviceMessage)\r\n            end\r\n            return nil\r\n        end\r\n    })\r\nend"},{"name":"entsoe_AreaCodes","isMain":false,"isOpen":false,"content":"-- See \"BZN\" Area codes at: https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html#_areas\r\n\r\nfunction QuickApp:createAreaVariables()\r\n    local level_var = {\r\n            name=self.global_var_area_name,\r\n            isEnum=true,\r\n            readOnly=true,\r\n            value=self.default_area_name,\r\n            enumValues={\"Austria (AT)\",\"Belgium (BE)\",\"Bosnia and Herz. (BA)\",\"Bulgaria (BG)\",\"Croatia (HR)\",\"Czech Republic (CZ)\",\"Denmark (DK1)\",\"Denmark (DK2)\",\"Estonia (EE)\",\"Finland (FI)\",\"France (FR)\",\"Germany (DE-LU)\",\"Greece (GR)\",\"Hungary (HU)\",\"Ireland (SEM)\",\"Italy (Calabria)\",\"Italy (SACOAC)\",\"Italy (SACODC)\",\"Italy (Centre-North)\",\"Italy (Centre-South)\",\"Italy (North)\",\"Italy (Sardinia)\",\"Italy (Sicily)\",\"Italy (South)\",\"Latvia (LV)\",\"Lithuania (LT)\",\"Luxembourg (LU)\",\"Netherlands (NL)\",\"North Macedonia (MK)\",\"Norway (NO1)\",\"Norway (NO2)\",\"Norway (NO2NSL)\",\"Norway (NO3)\",\"Norway (NO4)\",\"Norway (NO5)\",\"Poland (PL)\",\"Portugal (PT)\",\"Romania (RO)\",\"Serbia (RS)\",\"Slovakia (SK)\",\"Slovenia (SI)\",\"Spain (ES)\",\"Sweden (SE1)\",\"Sweden (SE2)\",\"Sweden (SE3)\",\"Sweden (SE4)\",\"Switzerland (CH)\",\"Ukraine (UA-IPS)\",\"United Kingdom (GB)\"}\r\n    }\r\n    api.post('/globalVariables/',level_var)    \r\nend\r\n\r\nfunction QuickApp:getAreaCode(areaName)\r\n    -- Set default Area code if \"areaName\" is missing.\r\n    if areaName == nil or areaName == \"\" then areaName = self.default_area_name end\r\n    \r\n    if (areaName == \"Austria (AT)\") then return \"10YAT-APG------L\" end\r\n    if (areaName == \"Belgium (BE)\") then return \"10YBE----------2\" end\r\n    if (areaName == \"Bosnia and Herz. (BA)\") then return \"10YBA-JPCC-----D\" end\r\n    if (areaName == \"Bulgaria (BG)\") then return \"10YCA-BULGARIA-R\" end\r\n    if (areaName == \"Croatia (HR)\") then return \"10YHR-HEP------M\" end\r\n    if (areaName == \"Czech Republic (CZ)\") then return \"10YCZ-CEPS-----N\" end\r\n    if (areaName == \"Denmark (DK1)\") then return \"10YDK-1--------W\" end\r\n    if (areaName == \"Denmark (DK2)\") then return \"10YDK-2--------M\" end\r\n    if (areaName == \"Estonia (EE)\") then return \"10Y1001A1001A39I\" end\r\n    if (areaName == \"Finland (FI)\") then return \"10YFI-1--------U\" end\r\n    if (areaName == \"France (FR)\") then return \"10YFR-RTE------C\" end\r\n    if (areaName == \"Germany (DE-LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Greece (GR)\") then return \"10YGR-HTSO-----Y\" end\r\n    if (areaName == \"Hungary (HU)\") then return \"10YHU-MAVIR----U\" end\r\n    if (areaName == \"Ireland (SEM)\") then return \"10Y1001A1001A59C\" end\r\n    if (areaName == \"Italy (Calabria)\") then return \"10Y1001C--00096J\" end\r\n    if (areaName == \"Italy (Centre-North)\") then return \"10Y1001A1001A70O\" end\r\n    if (areaName == \"Italy (Centre-South)\") then return \"10Y1001A1001A71M\" end\r\n    if (areaName == \"Italy (North)\") then return \"10Y1001A1001A73I\" end\r\n    if (areaName == \"Italy (SACOAC)\") then return \"10Y1001A1001A885\" end\r\n    if (areaName == \"Italy (SACODC)\") then return \"10Y1001A1001A893\" end\r\n    if (areaName == \"Italy (Sardinia)\") then return \"10Y1001A1001A74G\" end\r\n    if (areaName == \"Italy (Sicily)\") then return \"10Y1001A1001A75E\" end\r\n    if (areaName == \"Italy (South)\") then return \"10Y1001A1001A788\" end\r\n    if (areaName == \"Latvia (LV)\") then return \"10YLV-1001A00074\" end\r\n    if (areaName == \"Lithuania (LT)\") then return \"10YLT-1001A0008Q\" end\r\n    if (areaName == \"Luxembourg (LU)\") then return \"10Y1001A1001A82H\" end\r\n    if (areaName == \"Netherlands (NL)\") then return \"10YNL----------L\" end\r\n    if (areaName == \"North Macedonia (MK)\") then return \"10YMK-MEPSO----8\" end\r\n    if (areaName == \"Norway (NO1)\") then return \"10YNO-1--------2\" end\r\n    if (areaName == \"Norway (NO2)\") then return \"10YNO-2--------T\" end\r\n    if (areaName == \"Norway (NO2NSL)\") then return \"50Y0JVU59B4JWQCU\" end\r\n    if (areaName == \"Norway (NO3)\") then return \"10YNO-3--------J\" end\r\n    if (areaName == \"Norway (NO4)\") then return \"10YNO-4--------9\" end\r\n    if (areaName == \"Norway (NO5)\") then return \"10Y1001A1001A48H\" end\r\n    if (areaName == \"Poland (PL)\") then return \"10YPL-AREA-----S\" end\r\n    if (areaName == \"Portugal (PT)\") then return \"10YPT-REN------W\" end\r\n    if (areaName == \"Romania (RO)\") then return \"10YRO-TEL------P\" end\r\n    if (areaName == \"Serbia (RS)\") then return \"10YCS-SERBIATSOV\" end\r\n    if (areaName == \"Slovakia (SK)\") then return \"10YSK-SEPS-----K\" end\r\n    if (areaName == \"Slovenia (SI)\") then return \"10YSI-ELES-----O\" end\r\n    if (areaName == \"Spain (ES)\") then return \"10YES-REE------0\" end\r\n    if (areaName == \"Sweden (SE1)\") then return \"10Y1001A1001A44P\" end\r\n    if (areaName == \"Sweden (SE2)\") then return \"10Y1001A1001A45N\" end\r\n    if (areaName == \"Sweden (SE3)\") then return \"10Y1001A1001A46L\" end\r\n    if (areaName == \"Sweden (SE4)\") then return \"10Y1001A1001A47J\" end\r\n    if (areaName == \"Switzerland (CH)\") then return \"10YCH-SWISSGRIDZ\" end\r\n    if (areaName == \"Ukraine (UA-IPS)\") then return \"10Y1001C--000182\" end\r\n    if (areaName == \"United Kingdom (GB)\") then return \"10YGB----------A\" end\r\n\r\n    return \"\" -- No match\r\nend"},{"name":"i18n","isMain":false,"isOpen":false,"content":"class \"i18n\"\r\n\r\nphrases = {\r\n    en = {\r\n        [\"Refreshing\"] = \"Refreshing\",\r\n        [\"LoadingEnergyRates\"] = \"Loading energy rates\",\r\n        [\"Refresh\"] = \"Refresh\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Missing Energy rates for selected energy area\",\r\n        [\"ExchangeRate\"] = \"Exchange rate\",\r\n        [\"TodayRates\"] = \"Todays rates\",\r\n        [\"Range\"] = \"Range\",\r\n        [\"To\"] = \"to\",\r\n        [\"CurrentHour\"] = \"Current hour\",\r\n        [\"NextHour\"] = \"Next hour\",\r\n        [\"TodayAverage\"] = \"Today average\",\r\n        [\"TomorrowRatesReleases\"] = \"Tomorrow rates releases after\",\r\n        [\"TomorrowAverage\"] = \"Tomorrow average\",\r\n        [\"TomorrowRateRange\"] = \"Tomorrow rate range\",\r\n        [\"TariffRatePeriod\"] = \"Tariff rate period\",\r\n        [\"ThisMonthAverage\"] = \"This month average\",\r\n        [\"TotalTariffAverage\"] = \"Total tariff average\",\r\n        [\"Days\"] = \"Days\",\r\n        [\"days\"] = \"days\",\r\n        [\"EnergyArea\"] = \"Energy area\",\r\n        [\"AreaCode\"] = \"ENTSO-e AreaCode\",\r\n        [\"LanguageCode\"] = \"Language Code\",\r\n        [\"TariffRateHistory\"] = \"Tariff rate history\",\r\n        [\"MediumRatePrice\"] = \"Medium rate price\",\r\n        [\"Tax\"] = \"Energy prices include tax of\",\r\n        [\"OperatorCost\"] = \"Operator cost\",\r\n        [\"GridLosses\"] = \"Grid Losses percent cost\",\r\n        [\"GridAdjustment\"] = \"adjustment percent cost\",\r\n        [\"DealerCost\"] = \"Dealer cost\",\r\n        [\"GridCost\"] = \"Local Grid cost\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff rates\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Energy rate update\",\r\n        [\"VariableUpdate\"] = \"Variable update\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    dk = {\r\n        [\"Refreshing\"] = \"Opdatering\",\r\n        [\"LoadingEnergyRates\"] = \"IndlÃ¦sning af energisatser\",\r\n        [\"Refresh\"] = \"Opdatering\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Manglende energisatser for udvalgt energiomrÃ¥de\",\r\n        [\"ExchangeRate\"] = \"Valutakurs\",\r\n        [\"TodayRates\"] = \"I dag kurser\",\r\n        [\"Range\"] = \"RÃ¦kkevidde\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuel time\",\r\n        [\"NextHour\"] = \"NÃ¦ste time\",\r\n        [\"TodayAverage\"] = \"Dagens gennemsnit\",\r\n        [\"TomorrowRatesReleases\"] = \"Priserne i morgen offentliggÃ¸res\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gennemsnit\",\r\n        [\"TomorrowRateRange\"] = \"Prisinterval i morgen\",\r\n        [\"TariffRatePeriod\"] = \"Tarifperiode\",\r\n        [\"ThisMonthAverage\"] = \"Gennemsnit i denne mÃ¥ned\",\r\n        [\"TotalTariffAverage\"] = \"Samlet tarifgennemsnit\",\r\n        [\"Days\"] = \"Dage\",\r\n        [\"days\"] = \"dage\",\r\n        [\"EnergyArea\"] = \"EnergiomrÃ¥de\",\r\n        [\"AreaCode\"] = \"ENTSO-e OmrÃ¥denummer\",\r\n        [\"LanguageCode\"] = \"Sprogkode\",\r\n        [\"TariffRateHistory\"] = \"Tarifhistorie\",\r\n        [\"MediumRatePrice\"] = \"Mellempris pris\",\r\n        [\"Tax\"] = \"Priserne er inklusive moms\",\r\n        -- TODO: Translate\r\n        [\"OperatorCost\"] = \"Operator cost\",\r\n        [\"GridLosses\"] = \"Grid Losses percent cost\",\r\n        [\"GridAdjustment\"] = \"adjustment percent cost\",\r\n        [\"DealerCost\"] = \"Dealer cost\",\r\n        [\"GridCost\"] = \"Local Grid cost\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff rates\",\r\n\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Energirate opdatering\",\r\n        [\"VariableUpdate\"] = \"Variabel opdatering\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    no = {\r\n        [\"Refreshing\"] = \"Oppdaterer\",\r\n        [\"LoadingEnergyRates\"] = \"Laster spotpriser\",\r\n        [\"Refresh\"] = \"Oppdater\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser mangler for valgt energiomrÃ¥de\",\r\n        [\"ExchangeRate\"] = \"Vekslingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"OmrÃ¥de\",\r\n        [\"To\"] = \"til\",\r\n        [\"CurrentHour\"] = \"Aktuell time\",\r\n        [\"NextHour\"] = \"Neste time\",\r\n        [\"TodayAverage\"] = \"Dagens gjennomsnittsverdi\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgendagens priser er sluppet\",\r\n        [\"TomorrowAverage\"] = \"Morgendagens gjennomsnitt\",\r\n        [\"TomorrowRateRange\"] = \"Morgendagens omfang\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiode\",\r\n        [\"ThisMonthAverage\"] = \"NÃ¥vÃ¦rende mÃ¥neds gjennomsnitt\",\r\n        [\"TotalTariffAverage\"] = \"Gjennomsnittlig verdi totalt sett\",\r\n        [\"Days\"] = \"Dager\",\r\n        [\"days\"] = \"dager\",\r\n        [\"EnergyArea\"] = \"EnergiomrÃ¥de\",\r\n        [\"AreaCode\"] = \"OmrÃ¥deskode (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"SprÃ¥kkode\",\r\n        [\"TariffRateHistory\"] = \"Tariffhistorie\",\r\n        [\"MediumRatePrice\"] = \"Gjennomsnittspris\",\r\n        [\"Tax\"] = \"Prisene inkluderer skatt\",\r\n        -- TODO: Translate\r\n        [\"OperatorCost\"] = \"Operator cost\",\r\n        [\"GridLosses\"] = \"Grid Losses percent cost\",\r\n        [\"GridAdjustment\"] = \"adjustment percent cost\",\r\n        [\"DealerCost\"] = \"Dealer cost\",\r\n        [\"GridCost\"] = \"Local Grid cost\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff rates\",\r\n\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Spotpriser sist oppdatert\",\r\n        [\"VariableUpdate\"] = \"Variabler sist oppdatert\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    },\r\n    pt = {\r\n        [\"Refreshing\"] = \"Em atualizaÃ§Ã£o\",\r\n        [\"LoadingEnergyRates\"] = \"A carregar preÃ§os\",\r\n        [\"Refresh\"] = \"Atualizar\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"PreÃ§os inexistentes para o local selecionado\",\r\n        [\"ExchangeRate\"] = \"Taxa de cÃ¢mbio\",\r\n        [\"TodayRates\"] = \"PreÃ§os de hoje\",\r\n        [\"Range\"] = \"Intervalo\",\r\n        [\"To\"] = \"a\",\r\n        [\"CurrentHour\"] = \"Hora atual\",\r\n        [\"NextHour\"] = \"Hora seguinte\",\r\n        [\"TodayAverage\"] = \"MÃ©dia de hoje\",\r\n        [\"TomorrowRatesReleases\"] = \"IndicaÃ§Ã£o dos preÃ§os para amanhÃ£\",\r\n        [\"TomorrowAverage\"] = \"PreÃ§o mÃ©dio de amanhÃ£\",\r\n        [\"TomorrowRateRange\"] = \"Intervalo de preÃ§os para amanhÃ£\",\r\n        [\"TariffRatePeriod\"] = \"PerÃ­odo tarifÃ¡rio\",\r\n        [\"ThisMonthAverage\"] = \"MÃ©dia do mÃªs atual\",\r\n        [\"TotalTariffAverage\"] = \"PreÃ§o mÃ©dio total\",\r\n        [\"Days\"] = \"Dias\",\r\n        [\"days\"] = \"dias\",\r\n        [\"EnergyArea\"] = \"Local\",\r\n        [\"AreaCode\"] = \"CÃ³digo do local\",\r\n        [\"LanguageCode\"] = \"CÃ³digo de idioma\",\r\n        [\"TariffRateHistory\"] = \"HistÃ³rico de preÃ§os\",\r\n        [\"MediumRatePrice\"] = \"PreÃ§o mÃ©dio\",\r\n        [\"Tax\"] = \"PreÃ§o inclui taxa de\",\r\n        -- TODO: Translate\r\n        [\"OperatorCost\"] = \"Operator cost\",\r\n        [\"GridLosses\"] = \"Grid Losses percent cost\",\r\n        [\"GridAdjustment\"] = \"adjustment percent cost\",\r\n        [\"DealerCost\"] = \"Dealer cost\",\r\n        [\"GridCost\"] = \"Local Grid cost\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff rates\",\r\n\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e AtualizaÃ§Ã£o do preÃ§o\",\r\n        [\"VariableUpdate\"] = \"AtualizaÃ§Ã£o de variaÃ§Ãµes\",\r\n        [\"MissingTranslation\"] = \"TraduÃ§Ã£o inexistente para este idioma\",\r\n        [\"VeryHIGH\"] = \"Muito ALTO\",\r\n        [\"HIGH\"] = \"ALTO\",\r\n        [\"MEDIUM\"] = \"RAZOÃVEL\",\r\n        [\"LOW\"] = \"BAIXO\",\r\n        [\"VeryLOW\"] = \"Muito BAIXO\",\r\n    },\r\n    sv = {\r\n        [\"Refreshing\"] = \"Uppdaterar\",\r\n        [\"LoadingEnergyRates\"] = \"Laddar spotpriser\",\r\n        [\"Refresh\"] = \"Uppdatera\",\r\n        [\"MissingEnergyRatesForSelectedArea\"] = \"Spotpriser saknas fÃ¶r valt energiomrÃ¥de\",\r\n        [\"ExchangeRate\"] = \"VÃ¤xlingskurs\",\r\n        [\"TodayRates\"] = \"Dagens priser\",\r\n        [\"Range\"] = \"OmfÃ¥ng\",\r\n        [\"To\"] = \"till\",\r\n        [\"CurrentHour\"] = \"Innevarande timme\",\r\n        [\"NextHour\"] = \"Kommande timme\",\r\n        [\"TodayAverage\"] = \"Dagens medelvÃ¤rde\",\r\n        [\"TomorrowRatesReleases\"] = \"Morgondagens priser slÃ¤pps efter\",\r\n        [\"TomorrowAverage\"] = \"Morgondagens medelvÃ¤rde\",\r\n        [\"TomorrowRateRange\"] = \"Morgondagens omfÃ¥ng\",\r\n        [\"TariffRatePeriod\"] = \"Tariffperiod\",\r\n        [\"ThisMonthAverage\"] = \"Innevarande mÃ¥nads medelvÃ¤rde\",\r\n        [\"TotalTariffAverage\"] = \"MedelvÃ¤rde totalt\",\r\n        [\"Days\"] = \"Dagar\",\r\n        [\"days\"] = \"dagar\",\r\n        [\"EnergyArea\"] = \"EnergiomrÃ¥de\",\r\n        [\"AreaCode\"] = \"OmrÃ¥deskod (ENTSO-e)\",\r\n        [\"LanguageCode\"] = \"SprÃ¥kkod\",\r\n        [\"TariffRateHistory\"] = \"Tariff historik\",\r\n        [\"MediumRatePrice\"] = \"Medelpris\",\r\n        [\"Tax\"] = \"Priserna inkluderar skatt med\",\r\n        [\"OperatorCost\"] = \"OperatÃ¶rskostnad\",\r\n        [\"GridLosses\"] = \"NÃ¤tfÃ¶rlustskostnad\",\r\n        [\"GridAdjustment\"] = \"NÃ¤t justeringskostnad\",\r\n        [\"DealerCost\"] = \"LeverantÃ¶rskostnad\",\r\n        [\"GridCost\"] = \"Lokal nÃ¤tkostnad\",\r\n        [\"FibaroTariff\"] = \"FIBARO Tariff priser\",\r\n        [\"EnergyRateUpdate\"] = \"ENTSO-e Spotpriser senast uppdaterade\",\r\n        [\"VariableUpdate\"] = \"Variabler senast uppdaterade\",\r\n        [\"MissingTranslation\"] = \"Translation is missing for this language\",\r\n        [\"VeryHIGH\"] = \"VeryHIGH\",\r\n        [\"HIGH\"] = \"HIGH\",\r\n        [\"MEDIUM\"] = \"MEDIUM\",\r\n        [\"LOW\"] = \"LOW\",\r\n        [\"VeryLOW\"] = \"VeryLOW\",\r\n    }\r\n}\r\n\r\nfunction i18n:new(langCode)\r\n    self.isTranslated = true\r\n    if phrases[langCode] == nil then \r\n        langCode = \"en\"\r\n        self.isTranslated = false\r\n    end\r\n    self.languageCode = langCode\r\n    self.phrases = phrases[langCode]\r\n    return self\r\nend\r\n\r\nfunction i18n:get(key)\r\n    if key == nil then return \"\" end\r\n    if self.phrases[key] then return self.phrases[key] end\r\n    return key\r\nend"},{"name":"fibaroTariffRate","isMain":false,"isOpen":true,"content":"-- Update FIBARO Tariff rate table\r\nfunction QuickApp:updateFibaroTariffTable()\r\n    -- Exit if no data in global table or we got Service error\r\n    if (self:getGlobalFibaroVariable(self.global_var_fibaro_tariff_name, \"ON\") == \"OFF\" or self:tableCount(self.tariffData) == 0 or self.serviceSuccess == false) then return end\r\n\r\n    -- Get current FIBARO Energy Tariff rate data\r\n    local tariffData = api.get(\"/energy/billing/tariff\")\r\n    local currRate = tariffData.rate\r\n    local addTariffs = {}\r\n    local currentRateTime = os.date(\"%y%m%d%H\")\r\n    local count = 0\r\n        \r\n    -- Update FIBARO Additional Tariff table in local currency/kWh and local timezone\r\n    for index, tariff in pairs(self.tariffData) do\r\n        local startTime = self:toDate(tariff.id, \"%H:%M\", 0)\r\n        local endTime = self:toDate(tariff.id, \"%H:%M\", 1)\r\n        local tariffName = self:toDate(tariff.id, self:getDateFormat(), 0) ..\" \" ..startTime ..\" (\" ..tariff.rate ..\" â‚¬/MWh)\"\r\n\r\n        -- FIBARO only display price in kWh\r\n        local locRate = self:getLocalTariffRate(tariff.rate, self.exchangeRate, \"kWh\", self.tax, self.operatorCost, self.gridLosses, self.gridAdjustment, self.dealerCost, self.gridCost)\r\n        \r\n         -- FIBARO Tariff table can't have negative values :(\r\n        if (locRate < 0) then\r\n            tariffName = tariffName ..\" \" ..string.format(\"%f\", locRate) ..\" â›”\"\r\n            locRate = 0.00001\r\n        end\r\n\r\n        -- Get current rate\r\n        if (tariff.id == currentRateTime) then \r\n            currRate = locRate\r\n            tariffName = tariffName ..\" â­\"\r\n            self:d(\"Current energy price: \"..tariff.rate ..\"=\" ..currRate ..\" at exchange: \" ..self.exchangeRate ..\" Unit: \" ..self.unit ..\" ID: \" ..tariff.id ..\" - \" ..tariffName)\r\n        end\r\n        \r\n        -- Add additional tariff to local tariff table\r\n        local tariff = {\r\n            name = tariffName,\r\n            rate = locRate,\r\n            startTime = startTime,\r\n            endTime = endTime,\r\n            days = {string.lower(self:toDate(tariff.id, \"%A\", 0))}\r\n        }\r\n        table.insert(addTariffs, tariff)\r\n        count = count + 1\r\n    end\r\n\r\n    -- Save new tariff table to FIBARO Tariff table\r\n    local response, code = api.put(\"/energy/billing/tariff\", {\r\n        returnRate = tariffData.returnRate,\r\n        additionalTariffs = addTariffs,\r\n        name = tariffData.name,\r\n        rate = currRate\r\n    })\r\n\r\n    self:d(\"Update \" ..count ..\" FIBARO Tariffs with response code: \" .. tostring(code) .. \" - \\\"\" .. tariffData.name .. \"\\\" Rate: \" .. tariffData.rate .. \" => \" .. currRate)\r\nend"},{"name":"entsoe_TariffTable","isMain":false,"isOpen":true,"content":"function QuickApp:updateEnergyTariffTable(energyRateTable)\r\n    -- Exit if no data from ENTSO-e\r\n    if self:tableCount(energyRateTable) == 0 then return end\r\n\r\n    -- Set local variables\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    local tariffHourHistory = self.tariffHistory * 24\r\n    local updateTariff = false\r\n\r\n    -- Get current Energy Tariff data from global variables if empty\r\n    local tblCount = self:tableCount(self.tariffData)\r\n    if (tblCount == 0) then self.tariffData = self:getEnergyTariffTable() end\r\n\r\n    -- Add ENTSO-e raw rates to Energy tariff table if not already exists\r\n    local totalRate = 0;\r\n    for index, tariff in pairs(energyRateTable) do\r\n        totalRate = totalRate + tariff.rate\r\n        if not (self:existsInEnergyTariffTable(tariff.id)) then\r\n            table.insert(self.tariffData, tariff)\r\n            updateTariff = true\r\n            self:d(\"New ENTSO-e Energy rate added: \" ..tariff.id ..\" = \" ..tariff.rate)\r\n        end\r\n    end\r\n\r\n    -- If all rates in response table is 0 then not update Energy Tariff table, something is wrong!?\r\n    if (totalRate == 0) then\r\n        self.serviceSuccess = false -- Something got wrong in ENTSO-e request\r\n        self:d(\"Error in ENTSO-e Energy rate data!\")\r\n        return\r\n    end\r\n\r\n    -- Update Energy Tariff table if need to clean history\r\n    if updateTariff then tblCount = self:tableCount(self.tariffData) end\r\n    if (tblCount > tariffHourHistory) then updateTariff = true end\r\n\r\n    -- Update Energy tariff rates with sorted and cleaned Tariff data\r\n    if updateTariff then\r\n        -- Sort tariff table by Id (DateTime)\r\n        table.sort(self.tariffData, function (t1, t2) return t1.id < t2.id end )\r\n\r\n        -- Clean old Energy tartiff rates\r\n        if (tariffHourHistory > 0 and tariffHourHistory < tblCount) then\r\n            local cleanTariffs = {}\r\n            local startIndex = tblCount - tariffHourHistory\r\n            for index, tariff in pairs(self.tariffData) do\r\n                if index > startIndex then\r\n                    table.insert(cleanTariffs, tariff)\r\n                end\r\n            end\r\n            self.tariffData = cleanTariffs\r\n            self:d(\"Energy tariff table cleaned from old history: \" ..startIndex ..\" hours\")\r\n        end\r\n\r\n        -- Save Energy tariff table to FIBARO global variable\r\n        fibaro.setGlobalVariable(self.global_var_state_table_name, json.encode(self.tariffData))\r\n        self:d(\"Energy Tariff table updated in FIBARO global variables\")\r\n    end\r\nend\r\n\r\nfunction QuickApp:getEnergyRateData()\r\n    -- Get current Energy Tariff data from global variables if empty\r\n    local tblCount = self:tableCount(self.tariffData)\r\n    if (tblCount == 0) then self.tariffData = self:getEnergyTariffTable() end\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    \r\n    local energyPricesUpdated = false\r\n    local nowFormat = \"%y%m%d%H\"         -- Local timezone \"YYMMDDHH\"\r\n    local dayDate = os.date(\"%y%m%d\")    -- Local timezone \"YYMMDD\"\r\n    local monthDate = os.date(\"%y%m\")    -- Local timezone \"YYMM\"\r\n    local nextDayDate = os.date(\"%y%m%d\", os.time() + 86400)\r\n    local oneHour = 1 * 60 * 60          -- 1 hour\r\n    local previousRate = self.high_price -- Set default to High price\r\n    local currentRate = self.high_price  -- Set default to High price\r\n    local nextRate = self.high_price     -- Set default to High price\r\n    local totalCount = 0\r\n    local totalRate = 0\r\n    local totalDayCount = 0\r\n    local totalDayRate = 0\r\n    local totalMonthCount = 0\r\n    local totalMonthRate = 0\r\n    local minDayRate = 9999\r\n    local maxDayRate = 0\r\n    local totalNextDayCount = 0\r\n    local totalNextDayRate = 0    \r\n    local minNextDayRate = 9999\r\n    local maxNextDayRate = 0\r\n    local avgNextDayRate = 0\r\n    local nextDayRate = false\r\n    local firstIdDate = \"\"\r\n    local lastIdDate = \"\"\r\n\r\n    -- Sum each FIBARO tariff rate (Rate is in â‚¬/MWh and id is in local format \"YYMMDDHH\")\r\n    if (tblCount > 0) then\r\n        for index, tariff in pairs(self.tariffData) do\r\n            -- Set first and last id\r\n            if index == 1 then firstIdDate = tariff.id end\r\n            lastIdDate = tariff.id\r\n\r\n            -- Calculate Local Tariff Rate\r\n            local locRate = self:getLocalTariffRate(tariff.rate, self.exchangeRate, self.unit, self.tax, self.operatorCost, self.gridLosses, self.gridAdjustment, self.dealerCost, self.gridCost)\r\n\r\n            -- Set total values\r\n            totalRate = totalRate + locRate\r\n            totalCount = totalCount + 1\r\n            energyPricesUpdated = true\r\n\r\n            -- Sum today values \"YYMMDD\"\r\n            if (string.sub(tariff.id, 1, 6) == dayDate) then\r\n                totalDayRate = totalDayRate + locRate\r\n                totalDayCount = totalDayCount + 1\r\n                if locRate < minDayRate then minDayRate = locRate end\r\n                if locRate > maxDayRate then maxDayRate = locRate end\r\n            end\r\n            \r\n            -- Sum current month values \"YYMM\"\r\n            if (string.sub(tariff.id, 1, 4) == monthDate) then\r\n                totalMonthRate = totalMonthRate + locRate\r\n                totalMonthCount = totalMonthCount + 1\r\n            end\r\n\r\n            -- Sum tomorrow values\r\n            if (string.sub(tariff.id, 1, 6) == nextDayDate) then\r\n                totalNextDayRate = totalNextDayRate + locRate\r\n                totalNextDayCount = totalNextDayCount + 1\r\n                if locRate < minNextDayRate then minNextDayRate = locRate end\r\n                if locRate > maxNextDayRate then maxNextDayRate = locRate end\r\n            end\r\n\r\n            -- Set previous, current and next rate values\r\n            if (tariff.id == os.date(nowFormat, os.time() - oneHour)) then previousRate = locRate end\r\n            if (tariff.id == os.date(nowFormat, os.time()))           then currentRate = locRate end\r\n            if (tariff.id == os.date(nowFormat, os.time() + oneHour)) then nextRate = locRate end\r\n        end\r\n    end\r\n\r\n    -- Set minimum day rates to 0 if 9999\r\n    if (minNextDayRate >= 9999) then minNextDayRate = 0 end\r\n    if (minDayRate >= 9999) then minDayRate = 0 end\r\n    \r\n    -- Calculate tomorrow average values\r\n    if (totalNextDayCount > 0) then \r\n        avgNextDayRate = totalNextDayRate / totalNextDayCount \r\n        nextDayRate = true\r\n    end\r\n\r\n    -- Set return Tariff Data table\r\n    local tariffData = {\r\n        energyPricesUpdated = energyPricesUpdated,\r\n        count = totalCount,\r\n        previousRate = string.format(self.valueFormat, previousRate),\r\n        currentRate = string.format(self.valueFormat, currentRate),\r\n        nextRate = string.format(self.valueFormat, nextRate),\r\n        avgTotalRate = string.format(self.valueFormat, totalRate / totalCount),\r\n        avgDayRate = string.format(self.valueFormat, totalDayRate / totalDayCount),\r\n        avgDayCount = totalDayCount,\r\n        avgMonthRate = string.format(self.valueFormat, totalMonthRate / totalMonthCount),\r\n        avgMonthCount = totalMonthCount,\r\n        minDayRate = string.format(self.valueFormat, minDayRate),\r\n        maxDayRate = string.format(self.valueFormat, maxDayRate),\r\n        nextDayRate = nextDayRate,\r\n        avgNextDayRate = string.format(self.valueFormat, avgNextDayRate),\r\n        minNextDayRate = string.format(self.valueFormat, minNextDayRate),\r\n        maxNextDayRate = string.format(self.valueFormat, maxNextDayRate),\r\n        firstDate = self:toDate(firstIdDate, \"%Y-%m-%d\"),\r\n        lastDate = self:toDate(lastIdDate, \"%Y-%m-%d\")\r\n    }\r\n\r\n    self:d(\"Energy tariff - Count: \" ..tariffData.count ..\" (History \" ..(self.tariffHistory * 24) ..\" h), Previous Rate: \" ..tariffData.previousRate ..\", Current Rate: \" ..tariffData.currentRate ..\", next Rate: \" ..tariffData.nextRate ..\", Total avrage Rate: \" ..tariffData.avgTotalRate)\r\n\r\n    return tariffData\r\nend\r\n\r\nfunction QuickApp:IsEnergyTariffUpToDate()\r\n    if self.tariffHistory == nil then self.tariffHistory = 365 end\r\n    local tariffHourHistory = self.tariffHistory * 24\r\n    local tblCount = self:tableCount(self.tariffData)\r\n    local dateFormat = \"%y%m%d%H\"\r\n    local oneHour = 1 * 60 * 60        -- 1 hour\r\n    local nextDayShift = 24 * 60 * 60  -- 24 hours\r\n    local keepHistory = false\r\n    local previousExists = false\r\n    local currentExist = false\r\n    local nextExists = false\r\n    local nextDayExists = true\r\n\r\n    if (tblCount > tariffHourHistory) then \r\n        self:d(\"Energy tariff table need to be cleaned!\")\r\n        return false\r\n    end\r\n\r\n    -- ENTSO-e relese next day energy rate prices after 12:00 UTC each day\r\n    if (tonumber(os.date(\"%H\", os.time())) >= self:getRateReleaseTime(self.timezoneOffset)) then nextDayExists = false end\r\n\r\n    -- Check FIBARO Tariff if all rates already exists\r\n    for _, tariff in pairs(self.tariffData) do\r\n        if (tariff.id == os.date(dateFormat, os.time() - oneHour))      then previousExists = true end\r\n        if (tariff.id == os.date(dateFormat, os.time()))                then currentExist = true end\r\n        if (tariff.id == os.date(dateFormat, os.time() + oneHour))      then nextExists = true end\r\n        if (tariff.id == os.date(dateFormat, os.time() + nextDayShift)) then nextDayExists = true end\r\n        \r\n        if previousExists and currentExist and nextExists and nextDayExists then\r\n            self:d(\"Energy tariff table is already up to date\")\r\n            return true\r\n        end   \r\n    end\r\n\r\n    self:d(\"Energy tariff table need to be updated!\")\r\n    return false\r\nend\r\n\r\n-- Check if rate already exists in Energy tariff table\r\nfunction QuickApp:existsInEnergyTariffTable(match)\r\n    if self.tariffData == nil then return false end\r\n    for index, data in pairs(self.tariffData) do\r\n        if (tostring(data.id) == tostring(match)) then return true end\r\n    end\r\n    self:d(\"Energy tariff id \" ..match ..\" not exists!\")\r\n    return false\r\nend"}]}